---
layout: post
title: "笔试题总结"
subtitle: "算法笔试"
author: WenlSun"
header-style: text
tag:
  - 笔经
---



## 腾讯

### 1. 打怪兽游戏

小Q在玩一款打怪兽的游戏，他在之前的关卡已经获得了足够多的金币，当前关有n个怪兽，每个怪兽有$C_i$的血量，打死它可以获得$W_i$的金币， 问小Q通过当前关卡最多可以多获得多少金币。

输入：

输入两个数，n,m 。n表示怪兽的数量，m表示一个金币可以购买的血量

接下来n行，每行是一个怪兽的血量和打死它可以获得的金币。

输出：

通过当前关卡最多可以多获得的金币数

#### 参考代码

```C++
#include <iostream>

using namespace std;

const int N = 1010;

int c[N], w[N];

int main() {
    int n, m;
    while (cin >> n >> m) {
        for (int i = 0; i < n; i++) {
            cin >> c[i] >> w[i];
        }
        int cost = 0;   // 记录买血花了多少钱
        int blood = 0;  // 记录自己拥有的血量
        int gain = 0;   // 记录打怪兽获得的金币
        // 遍历每一只怪兽，可以选择打或者不打
        for (int i = 0; i < n; i++) {
            // 先购买可以打死当前怪兽的血量
            int cnt = 0;
            while (blood < c[i]) {
                cnt++;
                blood += m;
            }
            //如果买血花的金币小于等于打死获得的金币，说明值得打
            if (cnt - w[i] <= 0) {
                cost += cnt;
                blood -= c[i];
                gain += w[i];
                // 否则选择不打
            } else {
                blood -= cnt * m;
            }
        }
        cout << gain - cost << endl;
    }
    return 0;
}
```

### 2.  抛物线与直线围成的面积

求抛物线 $y^2 = 2Ax$ 和直线 $y = Bx + C$ 所围成的面积.

输入：A B C

输出：面积

思路：联合两个方程求解交点的y坐标，$y=\frac{A+-\sqrt{A^2-2ABC}}{B}$,

$\int_{y_1}^{y^2} \frac{y-C}{B}-\frac{y^2}{2A} dy $

然后对这个式子进行积分

#### 参考代码

```c++
#include <algorithm>
#include <iostream>
#include <vector>

using namespace std;

int f(int A, int B, int C) {
    int delta = pow(A, 2) - 2 * A * B * C;
    if (delta < 0) return 0;
    double y1 = (A - sqrt(delta)) / B, y2 = (A + sqrt(delta)) / B;
    double x2 = pow(y2, 2) / (2 * B) - C / B * y2 - pow(y2, 3) / (6 * A);
    double x1 = pow(y1, 2) / (2 * B) - C / B * y1 - pow(y1, 3) / (6 * A);
    return x2 - x1;
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        int A, B, C;
        cin >> A >> B >> C;
        double res = f(A, B, C);
        cout << res << endl;
    }
    return 0;
}
```



### 3. 牢房冲突

有n个牢房，编号为1\~n,每个牢房中都包含一个人，每个人都可以在1\~m中选择一个数字，如果有相邻牢房选择的数字相同，则会发生冲突。求发生冲突的情况有多少种？结果取mod100003.

输入： m ，n

输出： 发生冲突的情况数。

思路：数学推导，所有情形数-任意相邻房间数不同的情形，即m^n - m* (m-1)^(n-1)，考察点：快速幂算法：有模板！！！

#### 参考代码

```c++
#include <iostream>

using namespace std;

const int mod = 100003;

// 快速幂模板 m^k%p 时间复杂度O(logk)
int qmi(int m, int k, int p) {
    int res = 1 % p, t = m;
    while (k) {
        if (k & 1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}

int main() {
    LL m, n;
    while (cin >> m >> n) {
        int x1 = qmi(m, n, mod);
        int x2 = m * qmi(m - 1, n - 1, mod);
        cout << x1 - x2 << endl;
    }
}
```

### 4. 完美数

有n个数，每个数有k个属性值，对于任意的两个数$a_i$和$a_j$，如果 $a_{i1}$+$a_{j1} $= $a_{i2}$+$a_{j2}$ = ...=$a_{ik}$+$a_{jk}$,则成$a_i$和$a_j$是一对完美数。 求这n个数中总共有多少对完美数.

输入：
n, k 。n个数，每个数有k个属性。

接下来n行，每行k个属性

输出：

总共有多少对完美数

#### 参考代码

```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {
	// 待填
    
    return 0;
}
```

### 5. 最大关系网

有n对关系，比如A和B有关系，B和C有关系，则ABC关系。求这些关系中能构成的最大关系网中的人数。

输入：

n 。n对关系

接下来n行，每行是一对关系

输出：

这些关系中构建出来的最大关系网中的人数

#### 参考代码

```c++
#include <iostream>

using namespace std;

int main(){
    // 待填
    
    return 0;
}
```

## 阿里

### 1. 翻转01串

给你一串01组成的字符串，可以选择一个位置进行翻转，即0变1,1变0，同时与该位置相邻的位置也要进行翻转 如 11011 在0的位置翻转变为10101，问给定一个这样的串，最少经过多少次翻转可以变成全0串，如果变不成输出NO。

样例：

"01" --> NO

"011" --> 1

思路：每一个位置要么不翻转，要么只翻转一次，翻转两次相当于没翻转,然后深度优先搜索。LeeCode1284

#### 参考代码

``` c++
#include <iostream>
#include <string>
#include <vector>

using namespace std;

class Solution {
   public:
    int reverse(string s) {
        if (s == "1") {
            return 1;
        } else if (s == "0") {
            return 0;
        }
        int count = 0;
        if (helper(s, 0, 0)) {
            return res;
        } else {
            return -1;
        }
    }

   private:
    int res = 0;  // 记录翻转次数
    bool helper(string s, int index, int count) {
        string temp(s.size(), '0');  // 和s等长的全0串
        if (s == temp) {  // 如果等于全0串，则记录翻转次数，返回
            res = count;
            return true;
        }
        // 如果翻转的位置已经到达s的末尾，则不能翻转成全0串
        if (index == s.size()) {
            return false;
        }
        // 递归，要么翻转当前位置，要么不翻转当前位置
        // 翻转当前位置 调用reverse函数翻转，计数器count+1，并移动到下一个位置
        // 若不翻转，移到下一个位置，
        return helper(reverse(s, index), index + 1, count + 1) ||
               helper(s, index + 1, count);
    }

    // 翻转字符串中的每一个位置，注意边界情况
    string reverse(string s, int index) {
        int n = s.size() - 1;
        if (index == 0) {
            s[0] = s[0] == '0' ? '1' : '0';
            s[1] = s[1] == '0' ? '1' : '0';
        } else if (index == n) {
            s[n] = s[n] == '0' ? '1' : '0';
            s[n - 1] = s[n - 1] == '0' ? '1' : '0';
        } else if (index > 0 && index < n) {
            s[index - 1] = s[index - 1] == '0' ? '1' : '0';
            s[index] = s[index] == '0' ? '1' : '0';
            s[index + 1] = s[index + 1] == '0' ? '1' : '0';
        }
        return s;
    }
};

int main() {
    Solution solu = Solution();
    string str = "011111";
    int res = solu.reverse(str);
    if (res != -1) {
        cout << res << endl;
    } else {
        cout << "No";
    }
    return 0;
}
```

### 2.射鹿

有n头鹿，m只箭，每头鹿都有一定的血量，每只箭也有相应的伤害值，使用每只箭都有相应的花费，当箭的伤害值大于等于鹿的血量时，可以将其射死，问如果能将所有鹿射死，求需要的最少花费是多少，如果不能全部射死，就输出NO。

样例：

1 // 测试用例的组数

3 3 // n,m

1 2 3 // 鹿的血量

2 3 4 // 箭的伤害值

1 2 3 // 箭的花费

6 // 输出最小花费

思路：将鹿按血量排序，定义一个箭的结构体，包含伤害值和花费两个属性，将箭按照伤害值排序， 然后对每只鹿，用能将其射死且花费最小的箭射它，这儿用到按花费排序的优先队列。

#### 参考代码

``` c++
#include <algorithm>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

struct Arrow {
    int damage;
    int cost;
    Arrow(int x, int y) : damage(x), cost(y) {}
};

struct cmp {
    bool operator()(Arrow* a1, Arrow* a2) { return a1->cost > a2->cost; }
};

bool static compare(Arrow* a1, Arrow* a2) { return a1->damage < a2->damage; }

int main() {
    int T;
    cin >> T;
    for (int i = 0; i < T; i++) {
        int N, M;
        cin >> N >> M;
        vector<int> nums(N, 0);
        vector<Arrow*> arrows;
        for (int i = 0; i < N; i++) {
            cin >> nums[i];
        }
        vector<int> damage(M, 0);
        for (int i = 0; i < M; i++) {
            cin >> damage[i];
        }
        vector<int> cost(M, 0);
        for (int i = 0; i < M; i++) {
            cin >> cost[i];
        }
        for (int i = 0; i < M; i++) {
            Arrow* arrow = new Arrow(damage[i], cost[i]);
            arrows.push_back(arrow);
        }

        if (N > M) {
            cout << "NO";
        } else {
            // 定义优先队列 用于按花费大小存储伤害值高于血量的箭
            priority_queue<Arrow*, vector<Arrow*>, cmp> q;
            int res = 0;                                  // 记录结果
            bool can = true;                              // 能否全部射死
            sort(nums.begin(), nums.end());               // 按血量排序
            sort(arrows.begin(), arrows.end(), compare);  // 按伤害值排序

            int j = M - 1;
            for (int i = N - 1; i >= 0; i--) {
                // 将能射死当前鹿的箭入优先队列
                while (j >= 0 && arrows[j]->damage >= nums[i]) {
                    q.push(arrows[j]);
                    j--;
                }
                // 如果没有能射死当前鹿的箭，则不能全部射死
                if (q.size() == 0) {
                    cout << "NO";
                    can = false;
                    break;
                    //否则拿出花费最小的箭射死当前鹿
                } else {
                    Arrow* arrow = q.top();
                    q.pop();
                    res += arrow->cost;
                }
            }
            if (can) {
                cout << "Total cost: " << res;
            }
        }
    }
}
```

## 华为

## 快手

## 美团

## 拼多多

## 头条

## 网易互娱



