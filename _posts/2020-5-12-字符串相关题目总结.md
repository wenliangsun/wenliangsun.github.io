---
layout: post
title: "字符串相关题目总结"
subtitle: "字符串"
author: WenlSun"
header-style: text
tag:
  - 算法
---
## 最长无重复子串

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

输入：字符串

输出：最长无重复子串的长度

思路：双指针/滑动窗口

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    string s;
    while(cin >> s){
        // 双指针法 或者叫滑动窗口法
        unordered_map<char, int> hash;
        int res = 0;
        for (int i = 0, j = 0; i < s.size(); i++) {
            hash[s[i]]++;
            while (hash[s[i]] > 1) hash[s[j++]]--;
            res = max(res, i - j + 1);
        }
        cout << res << endl;
    }
    return 0;
}
```

## 最长回文子串

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

输入：字符串

输出：最长回文子串

思路：中心扩展法，也可以用动规

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

// 中心扩展法
string palindrome(string s, int l, int r) {
    while (l >= 0 && r < s.size() && s[l] == s[r]) {
        l--, r++;
    }
    return s.substr(l + 1, r - l - 1);
}

int main() {
    string s;
    while (cin >> s) {
        string res;
        for (int i = 0; i < s.size(); i++) {
            string s1 = palindrome(s, i, i);
            string s2 = palindrome(s, i, i + 1);
            res = res.size() > s1.size() ? res : s1;
            res = res.size() > s2.size() ? res : s2;
        }
        cout << res << endl;
    }
    return 0;
}
```

## 字符串转整数

请你来实现一个 atoi 函数，使其能将字符串转换成整数。在任何情况下，若函数不能进行有效的转换时，请返回 0 。

输入：字符串

输出：字符串对应的整数

思路：逐一转换，注意判断越界的代码！！！

### 判断越界代码模板

```c++
int res = 0;
for(auto n:nums){
    // 正数越界情况
    if(res > INT_MAX / 10 || (res == INT_MAX && n > 7)) return INT_MAX;
    // 负数越界情况
    if(res < INT_MIN / 10 || (res == INT_MIN && n < -8)) return INT_MIN;
}

```

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

int soi(string s) {
    if (s.empty()) return 0;
    int idx = 0, res = 0, sign = 1;
    while (idx < s.size() && s[idx] == ' ') idx++;
    if (idx < s.size()) {
        if (s[idx] == '-') {
            sign = -1;
            idx++;
        } else if (s[idx] == '+')
            idx++;
    }
    while (idx < s.size()) {
        auto c = s[idx];
        if (c < '0' || c > '9') break;
        int t = sign * (c - '0');
        // 注意这个判断溢出的代码
        if (res > INT_MAX / 10 || (res == INT_MAX / 10 && t > 7))
            return INT_MAX;
        if (res < INT_MIN / 10 || (res == INT_MIN / 10 && t < -8))
            return INT_MIN;
        res = res * 10 + t;
        idx++;
    }
    return res;
}

int main() {
    string s;
    while (cin >> s) {
        cout << soi << endl;
    }
    return 0;
}
```

## 正则表达式匹配

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。

+ '.' 匹配任意单个字符；
+ '*' 匹配零个或多个前面的那一个元素。
所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

输入：字符串和模式串

输出：是否匹配

思路：动态规划，回溯法

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

// 回溯法
bool dfs(string s, string p, int sIdx, int pIdx) {
    if (pIdx == p.size()) return sIdx == s.size();
    bool firstMatch =
        (sIdx != s.size() && (p[pIdx] == s[sIdx] || p[pIdx] == '.'));
    if (pIdx + 1 < p.size() && p[pIdx + 1] == '*') {
        return dfs(s, p, sIdx, pIdx + 2) ||
               (firstMatch && dfs(s, p, sIdx + 1, pIdx));
    } else
        return firstMatch && dfs(s, p, sIdx + 1, pIdx + 1);
}

int main() {
    string s, p;
    while (cin >> s >> p) {
        vector<vector<bool>> dp(s.size() + 1,
                                vector<bool>(p.size() + 1, false));
        dp[0][0] = true;
        // 考虑 "" 和a*a*a*匹配的情况
        for (int i = 2; i <= p.size(); i += 2) {
            if (p[i - 1] == '*') dp[0][i] = dp[0][i - 2];
        }
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 1; j <= p.size(); j++) {
                // 当前字符匹配
                if (p[j - 1] == '.' || s[i - 1] == p[j - 1])
                    dp[i][j] = dp[i - 1][j - 1];
                // 当前模式字符是 '*' 时
                if (p[j - 1] == '*') {
                    // 如果 '*' 的前一个字符和匹配串的当前字符不匹配
                    if (p[j - 2] != s[i - 1] && p[j - 2] != '.')
                        dp[i][j] = dp[i][j - 2];
                    else
                    // 否则匹配的话，可能匹配多次，匹配 1 次，匹配 0 次
                        dp[i][j] =
                            dp[i - 1][j] || dp[i][j - 1] || dp[i - 1][j - 2];
                }
            }
        }
        cout << dp[s.size()][p.size()] << endl;
    }
    return 0;
}
```

## 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 ""。

输入：字符串数组

输出：最长公共前缀

思路：水平线性扫描

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

// 暴力扫描
string longestCommonPrefix(vector<string>& strs) {
    if (strs.empty()) {
        return "";
    }
    string temp = strs[0];
    int index = 0;
    for (index; index < temp.size(); index++) {
        for (int i = 0; i < strs.size(); i++) {
            if (temp[index] != strs[i][index]) {
                return temp.substr(0, index);
            }
        }
    }
    return temp;
}

int main() {
    vector<string> strs;
    string s;
    while (cin >> s) {
        strs.push_back(s);
    }
    // 水平扫描法
    string prefix = strs[0];
    for (int i = 1; i < strs.size(); i++) {
        // 如果当前字符串中不存在前缀prefix，则丢掉前缀的最后一个字符直到存在。
        while (strs[i].find(prefix) != 0) {
            prefix = prefix.substr(0, prefix.size() - 1);
            if (prefix.empty()) {
                puts(" ");
            }
        }
    }
    cout << prefix << endl;
    return 0;
}
```

## 最小覆盖子串

给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。

输入：两个字符串

输出：最小覆盖子串

思路：滑动窗口法(1)使用双指针技巧，初始化`l`和`r`为0，把`[l,r]`称为一个窗口；(2)先不断增加`r`使得窗口满足字符串需求；(3)此时停止`r`的增加，而是增加`l`以缩小窗口，直至窗口中的字符串不在符合要求，每次增加`l`，都要更新一轮的结果。(4)重复(2)(3)直至`r`到达字符串的尽头。

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    string s, t;
    while (cin >> s >> t) {
        // 两个哈希表
        unordered_map<char, int> need, window;
        for (auto c : t) need[c]++;
        int l = 0, r = 0, idx = 0;
        int matched = 0, minLen = INT_MAX;
        while (r < s.size()) {
            auto c = s[r];
            // 如果需求字符串包含当前字符，则入窗口
            if (need.count(c)) {
                window[c]++;
                // 统计窗口中和需求字符串的匹配字符数
                if (window[c] == need[c]) matched++;
            }
            r++;
            // 如果窗口已经满足需求，则缩小窗口大小
            while (matched == need.size()) {
                // 更新最小覆盖子串长度
                if (r - l < minLen) {
                    minLen = r - l;
                    idx = l;
                }
                auto c = s[l];
                // 缩小窗口
                if (need.count(c)) {
                    window[c]--;
                    if (window[c] < need[c]) matched--;
                }
                l++;
            }
        }
        string res = minLen == INT_MAX ? "" : s.substr(idx, minLen);
        cout << res << endl;
    }
    return 0;
}
```

## 最短编辑距离

给你两个单词 s1 和 s2，请你计算出将 s1 转换成 s2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符; 删除一个字符; 替换一个字符。

输入：两个单词字符串

输出：最短编辑距离

思路：动态规划

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    string s1, s2;
    while (cin >> s1 >> s2) {
        vector<vector<int>> dp(s1.size() + 1, vector<int>(s2.size() + 1, 0));
        for (int i = 0; i <= s1.size(); i++) dp[i][0] = i;
        for (int j = 0; j <= s2.size(); j++) dp[0][j] = j;
        for (int i = 1; i <= s1.size(); i++) {
            for (int j = 1; j <= s2.size(); j++) {
                if (s1[i - 1] == s2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1];
                else
                    // 依次是插入 删除 替换
                    dp[i][j] = min(dp[i][j - 1] + 1,
                                   min(dp[i - 1][j] + 1, dp[i - 1][j - 1] + 1));
            }
        }
        cout << dp[s1.size()][s2.size()] << endl;
    }
    return 0;
}
```

## 最长公共子序列

给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。

输入：两个字符串

输出：最长公共子序列

思路：动态规划

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    string s1, s2;
    while (cin >> s1 >> s2) {
        vector<vector<int>> dp(s1.size() + 1, vector<int>(s2.size() + 1, 0));
        for (int i = 1; i <= s1.size(); i++) {
            for (int j = 1; j <= s2.size(); j++) {
                if (s1[i - 1] == s2[j - 1])
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                else
                    // 不相等说明当前字符不能同时出现
                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);
            }
        }
        cout << dp[s1.size()][s2.size()] << endl;
    }
    return 0;
}
```

## 最长回文子序列

给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。

输入：字符串

输出：最长回文子序列的长度

思路：动态规划

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    string s;
    while (cin >> s) {
        vector<vector<int>> dp(s.size(), vector<int>(s.size(), 0));
        // base case
        for (int i = 0; i < s.size(); i++) dp[i][i] = 1;
        // 注意这儿需要反着遍历
        for (int i = s.size() - 1; i >= 0; i--) {
            for (int j = i + 1; j < s.size(); j++) {
                if (s[i] == s[j])
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                else
                    // 如果不相等，说明这两个字符不能同时出现的区间，分别将字符加到原来的区间，取其中较大者
                    dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
        cout << dp[0][s.size() - 1] << endl;
    }
    return 0;
}
```

## 验证回文串

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

输入：字符串

输出：是否是回文串

思路：双指针

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

bool isNum(char c) {
    if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') ||
        (c >= '0' && c <= '9'))
        return true;
    return false;
}

int main() {
    string s;
    while (cin >> s) {
        int l = 0, r = s.size() - 1;
        bool isPalindrome = true;
        while (l < r) {
            while (isNum(s[l]) && l < r) l++;
            while (isNum(s[r]) && l < r) r--;
            if (toupper(s[l]) != toupper(s[r])) {
                isPalindrome = false;
                break;
            }
            l++, r--;
        }
        if (isPalindrome)
            cout << "yes" << endl;
        else
            cout << "false" << endl;
    }
    return 0;
}
```

## 分割回文串

给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。

输入：字符串

输出：所有可能的分割方案

思路：回溯 + 剪枝  每个节点表示截取剩余的字符串，产生前缀字符串时，判断前缀是否是回文，如果是回文，则分割，否则，剪枝；叶子结点是空字符串时，此时，从根节点到叶结点的路径就是结果集中的一个解。

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

vector<vector<string>> res;

// 判断是否是回文
bool check(string s, int l, int r) {
    while (l < r) {
        if (s[l] != s[r]) return false;
    }
    return true;
}

void dfs(string s, int begin, vector<string> path) {
    if (s.size() == begin) {
        res.push_back(path);
        return;
    }
    for (int i = begin; i < s.size(); i++) {
        // 注意这儿 可以进一步优化
        if (!check(s, begin, i)) continue;
        path.push_back(s.substr(begin, i - begin + 1));
        dfs(s, i + 1, path);
        path.pop_back();
    }
}

int main() {
    string s;
    while (cin >> s) {
        res.clear();
        vector<string> path;
        dfs(s, 0, path);
        for (int i = 0; i < res.size(); i++) {
            for (auto s : res[i]) {
                cout << s << ' ';
            }
            cout << endl;
        }
    }
    return 0;
}
```