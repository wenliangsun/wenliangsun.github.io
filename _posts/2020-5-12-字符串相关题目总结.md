---
layout: post
title: "字符串相关题目总结"
subtitle: "字符串"
author: WenlSun"
header-style: text
tag:
  - 算法
---
## 最后一个单词的长度

给定一个仅包含大小写字母和空格 ' ' 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。

输入：字符串

输出：最后一个单词的长度

思路：分别寻找边界

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    string s;
    while (getline(cin, s)) {
        int r = s.size() - 1;
        while (r > 0 && s[r] == ' ') r--;
        int l = r;
        while (l > 0 && s[l] != ' ') l--;
        cout << r - l << endl;
    }
    return 0;
}
```

## 字母异位词分组

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。

输入：一组字符串。

输出：对他们的分组

思路：利用哈希表 关键是对他们实施一个标准，这儿采用排序作为他们的键。

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    vector<string> strs;
    string s;
    while (cin >> s) {
        strs.push_back(s);
    }
    unordered_map<string, vector<string>> hash;
    // 关键是构建一个标准作为他们的键  这儿选择对他们进行排序
    for (auto str : strs) {
        string key = str;
        sort(key.begin(), key.end());
        hash[key].push_back(str);
    }
    vector<vector<string>> res;
    for (auto item : hash) {
        res.push_back(item.second);
    }
    for (int i = 0; i < res.size(); i++) {
        for (auto s : res[i]) {
            cout << s;
        }
        cout << endl;
    }
    return 0;
}
```

## 字符串相乘

给定两个以字符串形式表示的非负整数 s1 和 s2，返回 s1 和 s2 的乘积，它们的乘积也表示为字符串形式。

输入：两个数字字符串

输出：两个字符串的乘积

思路：模拟题。注意代码的写法技巧

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

string add(string s1, string s2) {
    string res = "";
    int carry = 0;
    // 注意这儿代码的写法 技巧
    for (int i = s1.size() - 1, j = s2.size() - 1; i >= 0 || j >= 0 || carry;
         i--, j--) {
        int n1 = i < 0 ? 0 : s1[i] - '0';
        int n2 = j < 0 ? 0 : s2[j] - '0';
        int sum = (n1 + n2 + carry) % 10;
        carry = (n1 + n2 + carry) / 10;
        res = to_string(sum) + res;
    }
    return res;
}

int main() {
    string s1, s2;
    while (cin >> s1 >> s2) {
        string res = "0";
        for (int i = s2.size() - 1; i >= 0; i--) {
            string t = "";
            int carry = 0;
            // 补零操作
            for (int j = s2.size() - 1; j > i; j--) {
                t += '0';
            }
            int n2 = s2[i] - '0';
            // 相乘操作
            for (int j = s1.size() - 1; j >= 0 || carry != 0; j--) {
                int n1 = j < 0 ? 0 : s1[j] - '0';
                int mul = (n1 * n2 + carry);
                t = to_string(mul % 10) + t;
                carry = mul / 10;
            }
            res = add(t, res);
        }
        cout << res << endl;
    }
    return 0;
}
```

## 通配符匹配

给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 '?' 和 '*' 的通配符匹配。

+ '?' 可以匹配任何单个字符
+ '*' 可以匹配任意字符串(包括空字符串)

输入：一个字符串和一个模式串

输出： 两个字符串是否匹配

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    string s, p;
    while (cin >> s >> p) {
        vector<vector<bool>> dp(s.size() + 1,
                                vector<bool>(p.size() + 1, false));
        // base case 空字符串匹配的情况
        dp[0][0] = true; 
        // 模式串匹配空字符串的情况
        for (int i = 0; i < p.size(); i++)
            dp[0][i + 1] = p[i] == '*' && dp[0][i];
        for (int i = 0; i < s.size(); i++) {
            for (int j = 0; j < p.size(); j++) {
                // 如果当前字符匹配
                if (s[i] == p[j] || p[j] == '?')
                    dp[i + 1][j + 1] = dp[i][j];
                    // 如果当前字符是 * 时
                else if (p[j] == '*')
                    dp[i + 1][j + 1] = dp[i][j] || dp[i][j + 1] || dp[i + 1][j];
            }
        }
        cout << dp[s.size()][p.size()] << endl;
    }
    return 0;
}
```

## 单词拆分

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

+ 拆分时可以重复使用字典中的单词
+ 可以假设字典中没有重复的单词

输入：一个字符串和一个单词字典

输出：能否拆分

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

// 暴力深搜
bool dfs(string s, unordered_set<string> dict, int begin) {
    if (begin == s.size()) return true;
    for (int i = begin; i < s.size(); i++) {
        if (dict.find(s.substr(begin, i - begin + 1)) != dict.end() &&
            dfs(s, dict, i + 1))
            return true;
    }
    return false;
}

// 备忘录式深搜
bool dfs2(string s, unordered_set<string> dict, int begin, vector<int>& memo) {
    if (begin == s.size()) return true;
    if (memo[begin]) return memo[begin] > 0;
    for (int i = begin; i < s.size(); i++) {
        if (dict.find(s.substr(begin, i - begin + 1)) != dict.end() &&
            dfs2(s, dict, i + 1, memo)) {
            memo[begin] = 1;
            return true;
        }
    }
    memo[begin] = -1;
    return false;
}

int main() {
    string s;
    cin >> s;
    string w;
    unordered_set<string> dict;
    while (cin >> w) {
        dict.insert(w);
    }
    // 动态规划
    vector<bool> dp(s.size() + 1,
                    false);  // 表示字符串前i个字符是否可以拆分成单词表中单词
    dp[0] = true;
    for (int i = 0; i < s.size(); i++) {
        for (int j = 0; j < i; j++) {
            if (dp[j] && dict.find(s.substr(j, i - j)) != dict.end()) {
                dp[i] = true;
                break;
            }
        }
    }
    cout << dp[s.size()] << endl;

    // 深搜
    cout << dfs(s, dict, 0) << endl;

    // 备忘录式深搜
    vector<int> memo(s.size(), 0);  // 0是未被访问  1是可以，-1是不可以
    cout << dfs2(s, dict, 0, memo) << endl;
    return 0;
}
```

## 串联所有单词的子串

给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。注意子串要与 words 中的单词完全匹配，中间不能有其他字符，但不需要考虑 words 中单词串联的顺序。

输入：一个字符串和一个单词字典

输出：输出匹配位置的起点

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

int main() {
    string s;
    cin >> s;
    unordered_map<string, int> word;
    string w;
    while (cin >> w) word[w]++;

    int wordlen = w.size();
    int len = word.size() * wordlen;
    for (int i = 0; i < s.size() - len + 1; i++) {
        unordered_map<string, int> window;
        int nums = 0;
        while (nums < word.size()) {
            string t = s.substr(i + nums * wordlen, wordlen);
            if (!word.count(t)) break;
            if (window.count(t) && window[t] + 1 <= word[t])
                window[t]++;
            else
                break;
            nums++;
        }
        if (nums == word.size()) cout << i << endl;
    }
    return 0;
}
```

## 电话号码的字母组合

输入：数字字符串

输出：所有组合

### 参考代码

```c++
#include <bits/stdc++.h>

using namespace std;

unordered_map<char, string> m = {{'2', "abc"}, {'3', "def"}, {'4', "ghi"},
                                 {'5', "jkl"}, {'6', "mno"}, {'7', "pqrs"},
                                 {'8', "tuv"}, {'9', "wxyz"}};

vector<string> res;

void dfs(string s, int b, string t) {
    if (b == s.size()) res.push_back(t);
    string ss = m[s[b]];
    for (auto c : ss) {
        dfs(s, b + 1, t + c);
    }
}

int main() {
    string s;
    while (cin >> s) {
        string t;
        dfs(s, 0, t);
    }
    return 0;
}
```