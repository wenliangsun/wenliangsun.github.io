---
layout: post
title: "深度学习问题总结"
subtitle: "深度学习"
author: WenlSun"
header-style: text
tag:
  - 面经
---
## DNN、CNN、RNN和LSTM的区别？

**DNN(多层感知机模型)**：它是一种多层神经网络结构，层与层之间以全连接的方式连接。模型具有较强的数据表征能力，但因为是全连接网络，模型的参数较多，容易出现过拟合，梯度消失等问题。

**CNN(卷积神经网络)**：它也是一种多层级的神经网络，由卷积层，池化层和全连接层组成，卷积层的层与层之间是局部连接和权重共享的。权重共享减少了网络模型需要训练的参数。

**RNN(递归神经网络)**：针对CNN无法对时间序列上的变化进行建模的局限，为了适应对时序数据的处理，RNN应运而生，它关键之处在于当前网络的隐藏状态会保留先前的输入信息，用来做当前网络的输入。它的模型是时间维度上的深度模型，可以对时序数据建模。

LSTM：

## 卷积神经网络

### 卷积神经网络的特点

局部连接，权值共享，池化操作，多层次结构

### 填充和步长问题

设输出的高和宽分别为$n_h$和$n_w$，即输入的形状是$n_h\times n_w$，卷积核的窗口的形状是$k_h\times k_w$。<br>
1. 无padding，步长为1时，则输出的特征图的形状是$(n_h-k_h+1) \times (n_w-k_w+1)$.
2. 有padding,即在高的两侧一共填充$p_h$行,在宽的两侧一共填充$p_w$行, 且当步长为1时，则输出的特征图的形状是$(n_h-k_h+p_h+1)\times (n_w-k_w+p_w+1)$。在很多情况下，会设置$p_h=k_h-1$和$p_w = k_w-1$来使得输入和输出的特征图具有相同的高和宽。假设$k_h$是奇数，则通常会在高的两侧填充$p_h/2$。如果$k_h$是偶数，一种可能是在输入的顶端一侧填充$\lceil p_h/2 \rceil$，即上取整，而在底端一侧填充$\lfloor p_h/2 \rfloor$，即下取整。在宽的两侧填充同理。卷积神经网络中通常使用奇数高宽的卷积核，所以两端上的填充个数相等。
3. 有padding,且有步长不为1时，即设高上的步长为$s_h$，宽上的步长是$s_w$时，输出的形状为$\lfloor (n_h-k_h+p_h+s_h)/s_h\rfloor \times \lfloor (n_w-k_w+p_w+s_w)/s_w\rfloor$。如果设置$p_h=k_h-1$和$p_w = k_w-1$，则此时的输出形状是简化为$\lfloor(n_h+s_h-1)/s_h\rfloor \times \lfloor(n_w+s_w-1)/s_w\rfloor$。更进一步，如果输入的高和宽能分别被高和宽上的步长整除，那么输出的形状是$(n_h/s_h)\times (n_w/s_w)$。

### 卷积核的大小(尺寸)为什么都是奇数的？这样有什么好处？

1. 更容易padding：如果卷积核尺寸是奇数，就可以从图像的两边对称的padding。
2. 保护位置信息：保证了锚点刚好在中间，方便以模块中心为标准进行滑动卷积，避免了位置信息发生偏移。
3. 奇数卷积核相对于偶数卷积核有中心点，对边沿、对线条更加敏感，可以更有效的提取边沿信息。所以通常使用奇数卷积核。

## 激活函数相关

### 为什么需要非线性激活函数？

**为什么需要激活函数？**<br>
1. 激活函数对模型学习、理解复杂和非线性的函数具有重要作用。
2. **激活函数可以引入非线性因素**。解释：如果不使用激活函数，则输出信号仅是一个简单的线性函数。线性函数一个一级多项式，线性方程的复杂度有限，从数据中学习复杂函数映射的能力很小。没有激活函数，神经网络将无法学习和模拟其他复杂类型的数据，例如图像、视频、音频、语音等。
3. 激活函数可以把当前特征空间通过一定的非线性映射转换到另一个空间，让数据能够更好的被分类。

### 为什么激活函数需要非线性函数？
1. 假若网络中全部是线性部件，那么线性的组合还是线性，与单独一个线性分类器无异。这样就做不到用非线性来逼近任意函数。
2. 使用非线性激活函数 ，以便使网络更加强大，增加它的能力，使它可以学习复杂的事物，复杂的表单数据，以及表示输入输出之间非线性的复杂的任意函数映射。使用非线性激活函数，能够从输入输出之间生成非线性映射。

### 常见的激活函数

1. sigmoid激活函数：函数的定义为：$ f(x) = \frac{1}{1 + e^{-x}} $，其值域为 $ (0,1) $。
2. tanh激活函数：函数的定义为：$ f(x) = tanh(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}} $，值域为 $ (-1,1) $。
3. Relu激活函数：函数的定义为：$ f(x) = max(0, x) $  ，值域为 $ [0,+∞) $；
4. Leak Relu 激活函数 ： 函数定义为： $ f(x) =  \left\{
\begin{aligned}
ax, \quad x<0 \\
x, \quad x>0
\end{aligned}
\right. $，值域为 $ (-∞,+∞) $。
5. SoftPlus 激活函数： 函数的定义为：$ f(x) = ln( 1 + e^x) $，值域为 $ (0,+∞) $。
6. softmax激活函数：函数定义为： $ \sigma(z)_j = \frac{e^{z_j}}{\sum_{k=1}^K e^{z_k}} $。多用于多分类神经网络的输出。

### 使用ReLU激活函数有什么优点(相比于sigmoid激活函数)？

1. 在区间变动很大的情况下，ReLU激活函数的导数或者激活函数的斜率都会远大于0。在实现的时候就是一个if-else语句，而sigmoid的需要进行浮点四则运算，因此，在实践中，使用ReLU激活函数通常比sigmoid激活函数更快。
2. sigmoid激活函数(tanh激活函数)的导数在正负饱和区的时候，梯度会接近于0，造成梯度消失，而ReLU激活函数在大于0的部分的导数是一个常数，不会发生梯度消失现象。
3. ReLU激活函数进入负半区时，梯度为0，此时神经元不会训练，**产生所谓的稀疏性**。Leaky ReLU不会产生这个问题。

**怎么理解ReLU(<0时)是非线性激活函数**？<br>
1. 单侧抑制
2. 相对宽阔的兴奋边界
3. 稀疏激活性：ReLU函数从图像上看，是一个分段线性函数，把所有的负值都变为0，而正值不变，这样就成为单侧抑制。因为有了这单侧抑制，才使得神经网络中的神经元也具有了稀疏激活性。从信号方面来看，即神经元同时只对输入信号的少部分选择性响应，大量信号被刻意的屏蔽了，这样可以提高学习的精度，更好更快地提取稀疏特征。当 $ x<0 $ 时，ReLU 硬饱和，而当 $ x>0 $ 时，则不存在饱和问题。ReLU 能够在 $ x>0 $ 时保持梯度不衰减，从而缓解梯度消失问题。

### 为什么tanh激活函数会比sigmoid激活函数的表现好？ (存疑)

因为tanh的均值为0，像sigmoid这样输出均值非0的函数，会导致后面的神经网络的输入全部为正，进而导致对权值求梯度的时候 全部为正，于是反向传播的时候 要么全部向着正方向更新 要么全部向着负方向更新，大大降低了更新效率 使其难以收敛；

## Batch Size相关问题

### 在合理的范围内，增大batch size有何好处？

1. 内存利用率提高了，大矩阵乘法的并行化效率提高。
2. 跑完一次epoch（所有数据）所需要的迭代次数减少，对于相同数据量的处理速度进一步加快。
3. 在一定范围内，一般来说batch size越大，其确定的下降方向越准，引起训练震荡越小。

### 盲目增大batch size有何坏处？

1. 内存利用率提高了，但是内存容量可能撑不住。
2. 跑完一次epoch(所有数据)所需的迭代次数减少，要想达到相同的精度，其所花费的时间大大增加了，从而对参数的更新也显得缓慢了
3. batch size增大到一定程度，其确定的下降方向已经基本不再改变。

### 调节batch size对训练效果影响到底如何？

1. batch size太小，模型表现效果极其糟糕。
2. 随着batch size的增大，处理相同数据量的速度越快。
3. 随着 Batch_Size 增大，达到相同精度所需要的 epoch 数量越来越多。
4. 由于上述两种因素的矛盾， Batch_Size 增大到某个时候，达到时间上的最优。
5. 由于最终收敛精度会陷入不同的局部极值，因此 Batch_Size 增大到某些时候，达到最终收敛精度上的最优。

### 深度学习中的batch size的大小对训练过程的影响是什么样的？

[浅析深度学习中Batch Size大小对训练过程的影响](https://flashgene.com/archives/70920.html)<br>[深度学习中的batch的大小对学习效果有何影响？](https://www.zhihu.com/question/32673260)<br>
由于目前主流深度学习框架处理mini-batch的反向传播时，默认都是先将每个mini-batch中每个instance得到的loss平均化之后再反求梯度，也就是说每次反向传播的梯度是对mini-batch中每个instance的梯度平均之后的结果，所以b的大小决定了相邻迭代之间的梯度平滑程度， b太小，相邻mini-batch间的差异相对过大，那幺相邻两次迭代的梯度震荡情况会比较严重，不利于收敛；<br>b越大，相邻mini-batch间的差异相对越小，虽然梯度震荡情况会比较小，一定程度上利于模型收敛，但如果b极端大，相邻mini-batch间的差异过小，相邻两个mini-batch的梯度没有区别了，整个训练过程就是沿着一个方向蹭蹭蹭往下走，很容易陷入到局部最小值出不来。

## 归一化相关问题

### 有哪些特征归一化的方法，为什么要做归一化？

在机器学习领域中，不同评价指标（即特征向量中的不同特征就是所述的不同评价指标）往往具有不同的量纲和量纲单位，这样的情况会影响到数据分析的结果，**特征归一化就是将所有的特征都统一到一个大致相同的数值区间内**。**为了消除指标之间的量纲影响，需要进行数据归一化处理，使得不同指标之间具有可比性。**

如果不进行归一化，那么由于特征向量中不同特征的取值相差较大，会导致目标函数变“扁”。这样在进行梯度下降的时候，梯度的方向就会偏离最小值的方向，走很多弯路，即训练时间过长。如果进行归一化以后，目标函数会呈现比较“圆”，这样训练速度大大加快，少走很多弯路。总结：归一化后加快了梯度下降法求解最优解的速度，还可以提高模型的精度。

常用的归一化方法：

+ **线性归一化(最大最小归一化)**：将原始数据进行线性变化，使结果映射到$[0,1]$区间.$x'=\frac{x-min(x)}{max(x)-min(x)}$。
+ **零均值归一化**：将原始数据映射到均值为0、标准差为1的分布上。$z=\frac{x-\mu}{\sigma}$

通过梯度下降法求解的模型通常需要归一化的，包括，线性回归，逻辑回归，支持向量机，神经网络等。但对于决策树则不用。

## 什么是BN(批归一化)？有什么作用？为什么BN会对学习率变的不敏感？

[深入理解Batch Normalization批标准化](https://www.cnblogs.com/guoyaohua/p/8724433.html)
[Batch Normalization原理与实战](https://zhuanlan.zhihu.com/p/34879333)
因为深层神经网络在做非线性变换前的激活输入值（就是那个x=WU+B，U是输入）**随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近(包河区)导致反向传播时低层神经网络的梯度消失。**

**BN作用**：BN就是通过一定的规范化手段，把每层神经网络输入的分布强行拉回到均值为0方差为1的标准正态分布，使得非线性函数的输入值落入到其比较敏感的区域，这样可以让梯度变大，避免梯度消失的问题，而且可以加快训练速度。

**BN**：对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间的饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入到比较敏感的区域，以此避免梯度消失问题。变换后某个神经元的激活x形成了均值为0，方差为1的正态分布，目的是把值往后续要进行的非线性变换的线性区拉动，增大导数值，增强反向传播信息流动性，加快训练收敛速度。<br>
**BN的优势：**<br>
1. **BN使得网络中每层输入数据的分布相对稳定，加速模型学习速度**
   + BN通过规范化与线性变换使得每一层网络的输入数据的均值与方差都在一定范围内，使得后一层网络不必不断去适应底层网络中输入的变化，从而实现了网络中层与层之间的解耦，允许每一层进行独立学习，有利于提高整个神经网络的学习速度。
2. **BN使得模型对网络中参数不那么敏感，简化调参过程，使得网络学习更加稳定**
   + 当学习率设置太高时，会使得参数更新步伐过大，容易出现震荡和不收敛。但是使用BN的网络将不会受到参数数值大小的影响。**经过BN操作以后，权重的缩放值会被“抹去”，因此保证了输入数据分布稳定在一定范围内。因此，在使用Batch Normalization之后，抑制了参数微小变化随着网络层数加深被放大的问题，使得网络对参数大小的适应能力更强**，此时我们可以设置较大的学习率而不用过于担心模型不收敛的风险。
   + BN把输入弄到一个合理范围内了，也就会把模型的输出限制在一个合理的范围内，因此学习率大一点或者稍微小一点就不会再导致模型输出落到激活函数的饱和区之类的地方
3. **BN允许网络使用饱和性激活函数（例如sigmoid，tanh等），缓解梯度消失问题**
   + 通过BN操作可以让激活函数的输入数据落在梯度非饱和区，缓解梯度消失的问题。
4. **BN具有一定的正则化效果**
   + 在Batch Normalization中，由于我们使用mini-batch的均值与方差作为对整体训练样本均值与方差的估计，尽管每一个batch中的数据都是从总体样本中抽样得到，但不同mini-batch的均值与方差会有所不同，这就为网络的学习过程中增加了随机噪音，与Dropout通过关闭神经元给网络训练带来噪音类似，在一定程度上对模型起到了正则化的效果。

## 优化算法有哪些？各有什么优势？

[各优化算法的优缺点整理](https://blog.csdn.net/zhouhong0284/article/details/80232412)
