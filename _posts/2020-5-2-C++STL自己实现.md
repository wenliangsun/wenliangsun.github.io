---
layout: post
title: "C++STL自己实现"
subtitle: "容器自己实现"
author: WenlSun"
header-style: text
tag:
  - C++
  - STL
---
## 实现自己的vector容器

###  参考代码

```c++
#include <iostream>

using namespace std;

/**
 * vector 低层实现
 */

template <typename T>

class MyVector {
   public:
    // 无参构造初始化
    MyVector() : p(nullptr), capacity(0), size(0) {}
    // 有参构造的初始化方式
    MyVector(int size, T data) {
        this->capacity = 20 + size;
        this->size = size;
        this->p = new T[this->capacity];
        for (int i = 0; i < this->size; i++) {
            this->p[i] = data;
        }
    }

    // 析构函数，释放掉唯一的指针
    ~MyVector() {
        if (p != nullptr) {
            delete[] p;
        }
    }

    // 拷贝构造函数
    MyVector(const MyVector& v) {
        this->capacity = v.capacity;
        this->size = v.size;
        this->p = new T[this->capacity];
        memcpy(this->p, v.p, this->size * sizeof(T));
    }

    // 插入，要判断溢出没
    void push_back(T data) {
        if (this->p == nullptr) {
            this->capacity = 20;
            this->size = 0;
            this->p = new T[this->capacity];
        }
        if (this->size == this->capacity) {
            T* new_p = new T[this->capacity * 2];
            memcpy(new_p, this->p, this->size * sizeof(T));
            this->capacity *= 2;
            delete[] p;
            this->p = new_p;
        }
        this->p[this->size] = data;
        this->size++;
    }

    // 删除最后一个元素
    void pop_back() {
        if (this->size > 1) {
            this->p[this->size - 1] = 0;
            this->size--;
        }
    }

    // 插入
    void insert(int pos, int data) {
        if (pos >= 0 && pos <= this->size) {
            if (this->size == this->capacity) {
                T* new_p = new T[this->capacity * 2];
                memcpy(new_p, this->p, this->size * sizeof(T));
                this->capacity * 2;
                delete[] p;
                this->p = new_p;
            }
            for (int i = this->size; i > pos; i--) {
                this->p[i] = this->p[i - 1];
            }
            this->p[pos] = data;
            this->size++;
        }
    }

    //清除，假装清除了
    void clear() { this->size == 0; }

    // 重载[]运算符，可以用[]修改函数
    T& operator[](int index) {
        if (index >= 0 && index < this->size) {
            return this->p[index];
        }
    }

    // 重载=运算符，其实和拷贝构造函数一样
    void operator=(const MyVector& v) {
        if (p != nullptr) {
            delete[] p;
            this->capacity = 0;
            this->size = 0;
            this->p = nullptr;
        }
        this->capacity = v.capacity;
        this->size = v.size;
        this->p = new T[this->capacity];
        memcpy(this->p, v.p, this->size * sizeof(T));
    }

    // int size() { return this->size; }

    // int capacity() { return this->capacity; }

   public:
    T* p;
    int capacity;
    int size;
};

int main() {
    MyVector<int> mv(3, 0);
    mv.push_back(34);
    mv.push_back(22);
    mv.push_back(10);
    mv.insert(2, 100);
    for (int i = 0; i < mv.size; i++) {
        cout << mv[i] << endl;
    }

    return 0;
}
```