---
layout: post
title: "回溯深搜广搜题目总结"
subtitle: "回溯深搜广搜"
author: WenlSun"
header-style: text
tag:
  - 算法
---
## 电话号码的字母组合(中等)

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。[电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

### 参考代码

```c++
vector<string> res;
//map<char, string> m = {{'2', "abc"}, {'3', "def"}, {'4', "ghi"},
//                        {'5', "jkl"}, {'6', "mno"}, {'7', "pqrs"},
//                        {'8', "tuv"}, {'9', "wxyz"}};
vector<string> letterCombinations(string digits) {
    if (digits.empty()) return res;
    string path;
    dfs(digits, 0, path);
    return res;
}

void dfs(string& digits, int idx, string& path) {
    if (idx == digits.size()) {
        res.push_back(path);
        return ;
    }
    string s = m[digits[idx]];
    for (auto c : s) {
        path.push_back(c);
        dfs(digits, idx + 1, path);
        path.pop_back();
    }
}
```

## 括号生成(中等)

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。[括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

### 参考代码

```c++
vector<string> res;
vector<string> generateParenthesis(int n) {
    string path;
    dfs(n, n, path); // 做减法
    return res;
}

void dfs(int l, int r, string& path) {
    if (l == 0 && r == 0) {
        res.push_back(path);
        return;
    }
    if (l > 0) {
        path.push_back('(');
        dfs(l - 1, r, path);
        path.pop_back();
    }
    if (l < r && r > 0) { // 右侧的剩余数量要大于左侧
        path.push_back(')');
        dfs(l, r - 1, path);
        path.pop_back();
    }
}
```

## 解数独(困难)

编写一个程序，通过已填充的空格来解决数独问题。[解数独](https://leetcode-cn.com/problems/sudoku-solver/)

### 参考代码

```c++
void solveSudoku(vector<vector<char>>& board) { dfs(board, 0, 0); }

bool dfs(vector<vector<char>>& board, int x, int y) {
    int n = 9, m = 9;
    if (y == m) return dfs(board, x + 1, 0); // 当前行结束，转下一行
    if (x == n) return true; // 到最后一行，完成
    if (board[x][y] != '.') return dfs(board, x, y + 1); // 已有数字，跳到下一个位置
    for (char i = '1'; i <= '9'; i++) { // 依次尝试每一个数字
        if (isValid(board, x, y, i)) {
            board[x][y] = i;
            if (dfs(board, x, y + 1)) return true;
            board[x][y] = '.';
        }
    }
    return false;
}

/**
 * 判断当前数字是否合法
 */
bool isValid(vector<vector<char>>& board, int x, int y, char c) {
    for (int i = 0; i < 9; i++) {
        if (board[x][i] == c) return false;
        if (board[i][y] == c) return false;
        if (board[(x / 3) * 3 + i / 3][(y / 3) * 3 + i % 3] == c)
            return false;
    }
    return true;
}
```

## 组合总和(中等)

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。[组合总和](https://leetcode-cn.com/problems/combination-sum/)

### 参考代码

```c++
vector<vector<int>> res;
vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
    if (!candidates.size()) return res;
    vector<int> path;
    dfs(candidates, target, 0, path); // 这儿必须要有起始位置
    return res;
}

void dfs(vector<int>& candidates, int target, int idx, vector<int>& path) {
    if (target == 0) {
        res.push_back(path);
        return;
    }
    // 从起始位置开始，前面的数字不能再用了！！！
    for (int i = idx; i < candidates.size(); i++) {
        if (candidates[i] <= target) {
            path.push_back(candidates[i]);
            dfs(candidates, target - candidates[i], i, path);
            path.pop_back();
        }
    }
}
```

## 组合总和II(中等)

## 组合总和III(中等)

## 全排列(中等)

## 全排列II(中等)

## N皇后(困难)

## N皇后II(困难)

## 第k个排列(中等)

## 组合(中等)

## 子集(中等)

## 子集II(中等)

## 单词搜索(中等)

## 单词搜索II(中等)

## 格雷编码(中等)

## 复原IP地址(中等)

## 累加数(中等)

## 计算各个位数不同的数字个数(中等)

## 二进制手表(简单)

## 优美的排列(中等)

## 字母大小写全排列(简单)

## 将数组拆分成斐波拉契数列(中等)

## 不同路径III(困难)

## 正方形数组的数目(困难)

## 活字印刷(中等)

## 黄金矿工(中等)

## 串联字符串的最大长度(中等)

## 铺瓷砖(困难)
