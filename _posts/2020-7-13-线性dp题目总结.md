---
layout: post
title: "线性dp题目总结"
subtitle: "动态规划"
author: WenlSun"
header-style: text
tag:
  - 算法
---

## 除数博弈

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：选出任一 x，满足 0 < x < N 且 N % x == 0 。用 N - x 替换黑板上的数字 N 。如果玩家无法执行这些操作，就会输掉游戏。只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。[除数博弈](https://leetcode-cn.com/problems/divisor-game/)

### 参考代码

```c++
bool divisorGame(int N) {
    if (N == 1) return false;
    if (N == 2) return true;
    vector<bool> dp(N + 1); // dp[i] 表示面对数字i当前玩家的输赢情况
    dp[2] = true;
    for (int i = 3; i <= N; i++) { //枚举玩家面临的数字
        for (int x = 1; x < i; x++) { // 当前玩家需要选一个满足要求的数字，而且选完之后确保下一轮dp[i-x]玩家输的情况。
            if (!(i % x) && !dp[i - x]) {
                dp[i] = true; //则我就会赢
                break;
            }
        }
    }
    return dp[N];
}

/**
 * 归纳法，遇奇则输，遇偶则赢
 */
bool divisorGame(int N) {
    if (N & 1) return false;
    return true;
}
```

## 连续子数组的最大和(简单)

输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。时间复杂度：$O(n)$[连续子数组的最大和](https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/)

### 参考代码

```c++
int maxSubArray(vector<int>& nums) {
    int n = nums.size();
    // 状态表示：dp[i] 表示以i为结尾的子数组的集合，其中的值表示子数组的最大和
    // 状态计算：dp[i] = max(dp[i-1], 0) + nums[i]
    vector<int> dp(n + 1);
    for (int i = 1; i <= n; i++) dp[i] = max(dp[i - 1], 0) + nums[i];
    int res = INT_MIN;
    for (int i = 1; i <= n; i++) res = max(res, dp[i]);
    return res;
}
/**
 * 优化版本，因为状态转移方程只与上一状态有关
 */
int maxSubArray(vector<int>& nums) {
    int last = 0, res = INT_MIN;
    for (auto n : nums) {
        int t = max(last, 0) + n;
        res = max(res, t);
        last = t;
    }
    return res;
}
```

## 使用最小花费爬楼梯(简单)

数组的每个索引作为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost(索引从0开始)。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。[使用最小花费爬楼梯](https://leetcode-cn.com/problems/min-cost-climbing-stairs/)

### 参考代码

```c++
int minCostClimbingStairs(vector<int>& cost) {
    // 状态表示：dp[i] 表示到达i层时花费的总和
    // 状态计算：dp[i] = cost[i] + min(dp[i - 1], dp[i - 2]) 
    // 当前位置花费为从当年位置爬需要的花费和从前面当当前位置的花费之和
    vector<int> dp(cost.size());
    dp[0] = cost[0];
    dp[1] = cost[1];
    for (int i = 2; i < cost.size(); i++) {
        // cost[i] 表示从当前位置爬需要的花费，
        // min(dp[i-1], dp[i-2]) 表示到达当前位置需要的最小花费(可以跳一阶到达，也可以是跳两节到达)
        dp[i] = cost[i] + min(dp[i - 1], dp[i - 2]);
    }
    // 最后取倒数第一阶和倒数第二阶中的最小值，因为可以从倒数第二阶可以直接跳到最后
    return min(dp[cost.size() - 1], dp[cost.size() - 2]);
}

// 空间优化版
int minCostClimbingStairs(vector<int>& cost) {
    int n = cost.size();
    if (n == 1) return cost[0];
    int a = cost[0], b = cost[1];
    for (int i = 2; i < n; i++) {
        int t = cost[i] + min(a, b);
        a = b, b = t;
    }
    return min(a, b);
}
```

## 比特位计数(中等)

给定一个非负整数 num。对于 0 ≤ i ≤ num 范围中的每个数字 i ，计算其二进制数中的 1 的数目并将它们作为数组返回。[比特位计数](https://leetcode-cn.com/problems/counting-bits/)

思路：动态规划+最低有效位，$P(x) = P(x/2) + (x mod 2)$。[参考题解](https://leetcode-cn.com/problems/counting-bits/solution/bi-te-wei-ji-shu-by-leetcode/)

### 参考代码

```c++
vector<int> countBits(int num) {
    vector<int> res(num + 1);
    for (int i = 1; i <= num; i++) {
        res[i] = res[i >> 1] + (i & 1); // 状态转移方程
    }
    return res;
}
// 朴素版本 时间复杂度O(nk)
vector<int> countBits(int num) {
    vector<int> res;
    for (int i = 0; i <= num; i++) {
        int n = i, cnt = 0;
        while (n) {
            cnt++;
            n = n & (n - 1);
        }
        res.push_back(cnt);
    }
    return res;
}
```

## 最大正方形(中等)

在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。[最大正方形](https://leetcode-cn.com/problems/maximal-square/)

思路：动态规划：状态表示：`dp[i][j]` 表示以i，j结尾的矩形的最大边长， 状态计算：`dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1`。[参考题解](https://leetcode-cn.com/problems/maximal-square/solution/li-jie-san-zhe-qu-zui-xiao-1-by-lzhlyle/)

### 参考代码

```c++
int maximalSquare(vector<vector<char>>& matrix) {
    if (!matrix.size() || !matrix[0].size()) return 0;
    int m = matrix.size(), n = matrix[0].size();
    vector<vector<int>> dp(m, vector<int>(n));
    int len = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (matrix[i][j] == '1') {
                if (!i || !j)
                    dp[i][j] = 1;
                else
                    dp[i][j] = min(dp[i - 1][j - 1],
                                    min(dp[i - 1][j], dp[i][j - 1])) +
                                1;
            }
            len = max(len, dp[i][j]);
        }
    }
    return len * len;
}
```

## 统计全为1的正方形子矩阵(中等)

给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。[统计全为 1 的正方形子矩阵](https://leetcode-cn.com/problems/count-square-submatrices-with-all-ones/)

思路：动态规划：状态表示：`dp[i][j]`以i，j结尾的正方形的数量；状态计算：`dp[i][j] = min(dp[i-1][j-1], min(dp[i - 1][j], dp[i][j-1])) + 1`

### 参考代码

```c++
int countSquares(vector<vector<int>>& matrix) {
    if (!matrix.size() || !matrix[0].size()) return 0;
    int m = matrix.size(), n = matrix[0].size();
    int res = 0; // 记录总的正方形数量
    vector<vector<int>> dp(m, vector<int>(n));
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (matrix[i][j]) {
                if (!i || !j)
                    dp[i][j] = 1;
                else
                    dp[i][j] = min(dp[i - 1][j - 1],
                                    min(dp[i - 1][j], dp[i][j - 1])) +
                                1;
                res += dp[i][j];
            }
        }
    }
    return res;
}
```

## 最小路径和(中等)

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

### 参考代码

```c++
int minPathSum(vector<vector<int>>& grid) {
    if (!grid.size() || !grid[0].size()) return 0;
    int m = grid.size(), n = grid[0].size();
    // 状态表示：dp[i][j]表示到达位置i，j的最小路径和
    // 状态计算：dp[i][j] = min(dp[i-1][j], dp[i][j - 1]) + grid[i][j]
    vector<vector<int>> dp(m, vector<int>(n));
    dp[0][0] = grid[0][0]; // 注意这儿的base case
    for (int i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];
    for (int j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
        }
    }
    return dp[m - 1][n - 1];
}
```

## 地下城游戏(困难)

一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。为了尽快到达公主，骑士决定每次只向右或向下移动一步。[地下城游戏](https://leetcode-cn.com/problems/dungeon-game/)

思路：从右下到左上状态转移。状态表示：dp[i][j]表示位置i，j到达终点需要的最小初始量；状态计算：dp[i][j] = max(min(dp[i+1][j], dp[i][j+1])- dungeon[i][j], 1)，当前状态只与dp[i+1][j]和dp[i][j+1]的最小值有关，且需要满足当前位置i，j的初始值达到min-dungeon[i][j], 并保证初始值要大于1。

### 参考代码

```c++
int calculateMinimumHP(vector<vector<int>>& dungeon) {
    int m = dungeon.size(), n = dungeon[0].size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1, INT_MAX));
    dp[m][n - 1] = dp[m - 1][n] = 1; // 边界初始化为1
    for (int i = m - 1; i >= 0; i--) {
        for (int j = n - 1; j >= 0; j--) {
            dp[i][j] =
                max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1);
        }
    }
    return dp[0][0];
}
```

## 三角形最小路径和(中等)

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。[三角形最小路径和](https://leetcode-cn.com/problems/triangle/)

### 参考代码

```c++
class Solution {
   public:
    /**
     * 用滚动数组优化空间复杂度
     * 考虑到之和上一层的数组有关，只用2层的数组，即所有的i坐标模2,或者&1两个等价
     * 空间复杂度：O(n)
     */
    int minimumTotal(vector<vector<int>>& g) {
        int n = g.size();
        vector<vector<long long>> dp(2, vector<long long>(n));
        dp[0][0] = g[0][0];
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                dp[i & 1][j] = INT_MAX;
                if (j > 0)
                    dp[i & 1][j] =
                        min(dp[i & 1][j], dp[i - 1 & 1][j - 1] + g[i][j]);
                if (j < i)
                    dp[i & 1][j] =
                        min(dp[i & 1][j], dp[i - 1 & 1][j] + g[i][j]);
            }
        }
        long long res = INT_MAX;
        for (int i = 0; i < n; i++) res = min(res, dp[n - 1 & 1][i]);
        return res;
    }

    /**
     * 状态表示 ：dp[i][j]
     * 表示到达第i层上第j个结点的所有路径集合，其值表示这些路径集合中的最小值
     * 状态计算 ：分为从左上来的和右上来的  左上来的是 dp[i][j] = min(dp[i][j],
     * dp[i-1][j-1]+g[i][j]) 右上来的是 dp[i][j] = min(dp[i][j], dp[i - 1][j] +
     * g[i][j])
     *
     * 空间复杂度：O(n^2)
     */
    int minimumTotal(vector<vector<int>>& g) {
        int n = g.size();
        vector<vector<long long>> dp(n, vector<long long>(n));
        dp[0][0] = g[0][0];
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= i; j++) {
                dp[i][j] = INT_MAX;  // 初始化最大
                // 左上来的
                if (j > 0) dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + g[i][j]);
                // 右上来的
                if (j < i) dp[i][j] = min(dp[i][j], dp[i - 1][j] + g[i][j]);
            }
        }
        long long res = INT_MAX;
        // 遍历一遍，求最小
        for (int i = 0; i < n; i++) {
            res = min(res, dp[n - 1][i]);
        }
        return res;
    }
};
```

## 两个字符串的最小ASCII删除和(中等)

给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。[两个字符串的最小ASCII删除和](https://leetcode-cn.com/problems/minimum-ascii-delete-sum-for-two-strings/)

思路：和最短编辑距离思路一样。状态表示：`dp[i][j]`表示s1的前i个字母和s2的前j个字母中需要删除的最小和；状态计算：`dp[i][j] = min(dp[i - 1][j - 1] + s1[i - 1] + s2[j - 1], min(dp[i - 1][j] + s1[i - 1], dp[i][j - 1] + s2[j - 1]))`。

### 参考代码

```c++
int minimumDeleteSum(string s1, string s2) {
    int m = s1.size(), n = s2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));
    for (int i = 1; i <= m; i++) dp[i][0] = dp[i - 1][0] + s1[i - 1]; // 边界情况
    for (int j = 1; j <= n; j++) dp[0][j] = dp[0][j - 1] + s2[j - 1];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s1[i - 1] == s2[j - 1]) // 字符相等的情况
                dp[i][j] = dp[i - 1][j - 1];
            else
                dp[i][j] = min(dp[i - 1][j - 1] + s1[i - 1] + s2[j - 1],
                                min(dp[i - 1][j] + s1[i - 1],
                                    dp[i][j - 1] + s2[j - 1]));
        }
    }
    return dp[m][n];
}
```

## 最低票价(中等)

在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。火车票有三种不同的销售方式：一张为期一天的通行证售价为 costs[0] 美元；一张为期七天的通行证售价为 costs[1] 美元；一张为期三十天的通行证售价为 costs[2] 美元。通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。[最低票价](https://leetcode-cn.com/problems/minimum-cost-for-tickets/)

思路：从前向后计算。状态表示：dp[i]表示到第i天所用的最小花费；状态计算：`dp[i] = min(dp[i-1] + costs[0], dp[i-7] + costs[1], dp[i-30] + costs[2])` 当第i天是需要出行的时候，否则`dp[i] = dp[i-1]`。[参考题解](https://leetcode-cn.com/problems/minimum-cost-for-tickets/solution/zui-di-piao-jie-by-leetcode-solution/)

### 参考代码

```c++
int mincostTickets(vector<int>& days, vector<int>& costs) {
    int n = days.size();
    int last = days[n - 1]; // 出行的最后一天
    vector<int> dp(last + 1); // 状态数组
    int idx = 0;
    for (int i = 1; i <= last; i++) {
        if (i == days[idx]) { // 当前天需要出行
            int cst = INT_MAX;
            int t1 = i - 1;
            int t7 = i - 7 > 0 ? i - 7 : 0;
            int t30 = i - 30 > 0 ? i - 30 : 0;
            cst = min(dp[t1] + costs[0], cst);
            cst = min(dp[t7] + costs[1], cst);
            cst = min(dp[t30] + costs[2], cst);
            dp[i] = cst;
            idx++;
        } else // 不需要出行
            dp[i] = dp[i - 1];
    }
    return dp[last];
}
```

## 等差数列划分(中等)

如果一个数列至少有三个元素，并且任意两个相邻元素之差相同，则称该数列为等差数列。[等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)

### 参考代码

```c++
class Solution {
   public:
    /**
     * 思路：暴力法
     * 先计算相邻两个元素之间的差，然后枚举区间起点和枚举区间终点，判断区间内是不是等差数列即可
     * 时间复杂度：O(n^3)
     */
    int numberOfArithmeticSlices(vector<int>& A) {
        int cnt = 0, n = A.size();
        for (int s = 0; s < n - 2; s++) {      // 枚举起点
            int d = A[s + 1] - A[s];           // 计算等差
            for (int e = s + 2; e < n; e++) {  // 枚举终点
                int k = 0;
                for (k = s + 1; k <= e; k++) {  // 判断区间是不是等差数列
                    if (A[k] - A[k - 1] != d) break;
                }
                if (k > e) cnt++;  // 区间是等差数列的话，计数+1
            }
        }
        return cnt;
    }

    /**
     * 优化的暴力
     * 时间复杂度：O(n^2)
     */
    int numberOfArithmeticSlices(vector<int>& A) {
        int cnt = 0, n = A.size();
        for (int s = 0; s < n - 2; s++) {  // 枚举区间起点
            int d = A[s + 1] - A[s];
            for (int e = s + 2; e < n; e++) {  // 枚举区间终点
                if (A[e] - A[e - 1] == d)      // 判断是否等差
                    cnt++;
                else
                    break;
            }
        }
        return cnt;
    }

    /**
     * 动态规划
     * 状态表示：dp[i]表示以i结尾的等差数列的子数组个数
     * 状态计算：dp[i] = 1 + dp[i-1]
     */
    int numberOfArithmeticSlices(vector<int>& A) {
        int n = A.size();
        int sum = 0;
        vector<int> dp(A.size());
        for (int i = 2; i < n; i++) {
            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
                dp[i] = 1 + dp[i - 1];
                sum += dp[i];
            }
        }
        return sum;
    }
    // 状态压缩
    int numberOfArithmeticSlices(vector<int>& A) {
        int n = A.size(), sum = 0, dp = 0;
        for (int i = 2; i < n; i++) {
            if (A[i] - A[i - 1] == A[i - 1] - A[i - 2]) {
                dp = 1 + dp;
                sum += dp;
            } else
                dp = 0;
        }
        return sum;
    }
};
```

## 不同路径(中等)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？[不同路径](https://leetcode-cn.com/problems/unique-paths/)

思路：状态表示：`dp[i][j]`表示到达i，j位置的方案数；状态计算：`dp[i][j] = dp[i - 1][j] + dp[i][j-1]`。

### 参考代码

```c++
int uniquePaths(int m, int n) {
    vector<vector<int>> dp(m, vector<int>(n));
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (!i || !j)
                dp[i][j] = 1;
            else
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    return dp[m - 1][n - 1];
}
```

## 不同路径II(中等)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？[不同路径II](https://leetcode-cn.com/problems/unique-paths-ii/)

### 参考代码

```c++
int uniquePathsWithObstacles(vector<vector<int>>& g) {
    int n = g.size(), m = g[0].size();
    vector<vector<long long>> dp(n, vector<long long>(m));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (g[i][j]) continue;                // 障碍
            if (!i && !j) dp[i][j] = 1;           // 起点
            if (i > 0) dp[i][j] += dp[i - 1][j];  // 左边来的
            if (j > 0) dp[i][j] += dp[i][j - 1];  // 右边来的
        }
    }
    return dp[n - 1][m - 1];
}
```

## 回文子串(中等)

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。[回文子串](https://leetcode-cn.com/problems/palindromic-substrings/)

### 参考代码

```c++
class Solution {
   public:
    /**
     * 中心扩展法
     * 枚举每一个可能的中心位置，长度为n的字符串，有2*n-1个中心，然后向两边扩展
     */
    int countSubstrings(string s) {
        int n = s.size(), res = 0;
        for (int i = 0; i < 2 * n - 1; i++) {
            int l = i / 2, r = l + i % 2;  // 注意这儿求中心位置的方法
            while (l >= 0 && r < n && s[l] == s[r]) {
                res++, r--, l++;
            }
        }
        return res;
    }
    /**
     * 动态规划
     * 状态表示：dp[i][j]表示字符串i到j的子串是否是回文串
     * 状态计算：见代码
     */
    int countSubstrings(string s) {
        int res = 0, n = s.size();
        vector<vector<bool>> dp(n, vector<bool>(n));
        for (int j = 0; j < n; j++) {
            dp[j][j] = true;
            res++;
            for (int i = 0; i < j; i++) {
                dp[i][j] = (s[i] == s[j]) && (j - i < 2 || dp[i + 1][j - 1]);
                if (dp[i][j]) res++;
            }
        }
        return res;
    }
};
```

## 下降路径最小和(中等)

给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。[下降路径最小和](https://leetcode-cn.com/problems/minimum-falling-path-sum/)

思路：和三角形最小路径和类似，这个可称为正方形最小路径和。状态表示：`dp[i][j]`到达表示第i层第j列的路径最小和；状态计算：`dp[i][j] = min(dp[i - 1][j - 1], dp[i-1][j], dp[i-1][j+1]) + A[i][j]`。时间复杂度：$O(n^2)$，空间复杂度：$O(n^2)$。

### 参考代码

```c++
int INF = 10000; 
int minFallingPathSum(vector<vector<int>>& A) {
    int n = A.size();
    vector<vector<int>> dp(n, vector<int>(n, INF));
    for (int i = 0; i < n; i++) dp[0][i] = A[0][i];
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < n; j++) {
            dp[i][j] = min(dp[i][j], dp[i - 1][j] + A[i][j]);
            if (j > 0) dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + A[i][j]);
            if (j < n - 1) dp[i][j] = min(dp[i][j], dp[i - 1][j + 1] + A[i][j]);
        }
    }
    int res = INT_MAX;
    for (int i = 0; i < n; i++) res = min(res, dp[n - 1][i]);
    return res;
}
```

## 