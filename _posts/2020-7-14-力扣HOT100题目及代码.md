---
layout: post
title: "力扣HOT100题目及代码"
subtitle: "力扣100"
author: WenlSun"
header-style: text
tag:
  - 算法
---
## 两数之和(简单)

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。[两数之和](https://leetcode-cn.com/problems/two-sum/)

### 参考代码

```c++
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> hash;
    for (int i = 0; i < nums.size(); i++) hash[nums[i]] = i;
    for (int i = 0; i < nums.size(); i++) {
        if (hash.count(target - nums[i]) && hash[target - nums[i]] != i)
            return {i, hash[target - nums[i]]};
    }
    return {-1, -1};
}
```

## 两数相加(中等)

给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。[两数相加](https://leetcode-cn.com/problems/add-two-numbers/)

### 参考代码

```c++
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    auto dummy = new ListNode(-1);
    auto p = dummy;
    int carry = 0;
    while (l1 || l2 || carry) {
        int n1 = l1 ? l1->val : 0;
        int n2 = l2 ? l2->val : 0;
        int sum = (n1 + n2 + carry) % 10;
        carry = (n1 + n2 + carry) / 10;
        if (l1) l1 = l1->next;
        if (l2) l2 = l2->next;
        p->next = new ListNode(sum);
        p = p->next;
    }
    return dummy->next;
}
```

## 无重复字符的最长子串(中等)

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。[无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)

### 参考代码

```c++
int lengthOfLongestSubstring(string s) {
    unordered_map<char, int> hash;
    int res = 0;
    for (int i = 0, j = 0; j < s.size(); j++) {
        hash[s[j]]++;
        while (hash[s[j]] > 1) hash[s[i++]]--;
        res = max(res, j - i + 1);
    }
    return res;
}
```

## 寻找两个正序数组的中位数(困难)

给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。你可以假设 nums1 和 nums2 不会同时为空。[寻找两个正序数组的中位数](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/)

### 参考代码

```c++
double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    vector<int> res;
    int p1 = 0, p2 = 0;
    while (p1 < nums1.size() && p2 < nums2.size()) {
        if (nums1[p1] < nums2[p2])
            res.push_back(nums1[p1++]);
        else
            res.push_back(nums2[p2++]);
    }
    while (p1 < nums1.size()) res.push_back(nums1[p1++]);
    while (p2 < nums2.size()) res.push_back(nums2[p2++]);
    if (res.size() & 1)
        return res[res.size() / 2];
    else
        return (double)(res[res.size() / 2] + res[res.size() / 2 - 1]) / 2;
}
```

## 最长回文子串(中等)

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。[最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

### 参考代码

```c++
string longestPalindrome(string s) {
    string res;
    for (int i = 0; i < s.size(); i++) {
        string s1 = helper(s, i, i);
        string s2 = helper(s, i, i + 1);
        res = res.size() > s1.size() ? res : s1;
        res = res.size() > s2.size() ? res : s2;
    }
    return res;
}

string helper(string s, int l, int r) {
    while (l >= 0 && r < s.size() && s[l] == s[r]) l--, r++;
    return s.substr(l + 1, r - l - 1);
}
```

## 正则表达式匹配(困难)

给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。[正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

### 参考代码

```c++
bool isMatch(string s, string p) {
    int m = s.size(), n = p.size();
    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1));
    dp[0][0] = true;
    for (int i = 2; i <= n; i++)
        if (p[i - 1] == '*') dp[0][i] = dp[0][i - 2];
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (s[i - 1] == p[j - 1] || p[j - 1] == '.')
                dp[i][j] = dp[i - 1][j - 1];
            if (p[j - 1] == '*') {
                if (p[j - 2] != s[i - 1] && p[j - 2] != '.')
                    dp[i][j] = dp[i][j - 2];
                else
                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1] || dp[i][j - 2];
            }
        }
    }
    return dp[m][n];
}
```

## 盛最多水的容器(中等)

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。[盛最多水的容器](https://leetcode-cn.com/problems/container-with-most-water/)

### 参考代码

```c++
int maxArea(vector<int>& height) {
    int l = 0, r = height.size() - 1;
    int res = 0;
    while (l < r) {
        res = max(res, min(height[l], height[r]) * (r - l));
        if (height[l] < height[r])
            l++;
        else
            r--;
    }
    return res;
}
```

## 三数之和(中等)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。[三数之和](https://leetcode-cn.com/problems/3sum/)

### 参考代码

```c++
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> res;
    if (nums.size() < 3) return res;
    sort(nums.begin(), nums.end());  // 为了去重
    int n = nums.size();
    for (int i = 0; i < n - 2; i++) {
        if (i == 0 || nums[i] != nums[i - 1]) { // 第一次去重
            int l = i + 1, r = n - 1;
            while (l < r) {
                if (nums[l] + nums[r] > -nums[i])
                    r--;
                else if (nums[l] + nums[r] < -nums[i])
                    l++;
                else {
                    if (l == i + 1 || nums[l] != nums[l - 1]) { // 第二次去重
                        res.push_back({nums[l], nums[r], nums[i]});
                    }
                    l++, r--;
                }
            }
        }
    }
    return res;
}
```

## 电话号码的字母组合(中等)

给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。[电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)

### 参考代码

```c++
vector<string> res;
// 设置键盘的映射
vector<string> letterCombinations(string digits) {
    if (digits.empty()) return res;
    string path;
    dfs(digits, 0, path);
    return res;
}

void dfs(string& s, int idx, string& path) {
    if (idx == s.size()) {
        res.push_back(path);
        return;
    }

    string t = m[s[idx]];
    for (auto c : t) {
        path.push_back(c);
        dfs(s, idx + 1, path);
        path.pop_back();
    }
}
```

## 删除链表的倒数第N个节点(中等)

给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。[删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

### 参考代码

```c++
ListNode* removeNthFromEnd(ListNode* head, int n) {
    if (!head) return nullptr;
    auto dummy = new ListNode(-1);
    dummy->next = head;
    auto pre = dummy, cur = head;
    for (int i = 0; i < n; i++) cur = cur->next;
    while (cur) {
        pre = pre->next;
        cur = cur->next;
    }
    pre->next = pre->next->next;
    return dummy->next;
}
```

## 有效的括号(简单)

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。有效字符串需满足：左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。[有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)

### 参考代码

``` c++
bool isValid(string s) {
    if (s.empty()) return true;
    
    stack<char> stk;
    for (auto c : s) {
        if (stk.empty())
            stk.push(c);
        else if (c == m[stk.top()])
            stk.pop();
        else
            stk.push(c);
    }
    return stk.empty();
}
```

## 合并两个有序链表(简单)

将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。[合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)

### 参考代码

```c++
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    auto dummy = new ListNode(-1);
    auto p = dummy;
    while (l1 && l2) {
        if (l1->val < l2->val) {
            p->next = l1;
            l1 = l1->next;
            p = p->next;
        } else {
            p->next = l2;
            l2 = l2->next;
            p = p->next;
        }
    }
    while (l1) {
        p->next = l1;
        l1 = l1->next;
        p = p->next;
    }
    while (l2) {
        p->next = l2;
        l2 = l2->next;
        p = p->next;
    }
    return dummy->next;
}
```

## 括号生成(中等)

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。[括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

### 参考代码

```c++
vector<string> res;
// 回溯 做减法
vector<string> generateParenthesis(int n) {
    string path;
    dfs(n, n, path);
    return res;
}

void dfs(int l, int r, string& path) {
    if (l == 0 && r == 0) {
        res.push_back(path);
        return;
    }
    if (l > 0) {
        path.push_back('(');
        dfs(l - 1, r, path);
        path.pop_back();
    }
    if (l < r && r > 0) {
        path.push_back(')');
        dfs(l, r - 1, path);
        path.pop_back();
    }
}
```

## 合并k个排序链表(困难)

合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。[合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

### 参考代码

```c++
ListNode* mergeKLists(vector<ListNode*>& lists) {
    return merge(lists, 0, lists.size() - 1);
}

// 分治 两路两路归并
ListNode* merge(vector<ListNode*>& lists, int l, int r) {
    if (l == r) return lists[l];
    if (l < r) {
        int mid = (l + r) >> 1;
        return mergeLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }
    return nullptr;
}

ListNode* mergeLists(ListNode* l1, ListNode* l2) {
    auto dummy = new ListNode(-1);
    auto p = dummy;
    while (l1 && l2) {
        if (l1->val < l2->val) {
            p->next = l1;
            l1 = l1->next;
            p = p->next;
        } else {
            p->next = l2;
            l2 = l2->next;
            p = p->next;
        }
    }
    while (l1) {
        p->next = l1;
        l1 = l1->next;
        p = p->next;
    }
    while (l2) {
        p->next = l2;
        l2 = l2->next;
        p = p->next;
    }
    return dummy->next;
}
```

## 下一个排列(中等)

实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。[下一个排列](https://leetcode-cn.com/problems/next-permutation/)

### 参考代码

```c++

```

## 最长有效括号(困难)

给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。[最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

### 参考代码

```c++
int longestValidParentheses(string s) {
    int l = 0, r = 0, maxLen = 0;
    for (int i = 0; i < s.size(); i++) { // 从左向右统计
        if (s[i] == '(')
            l++;
        else
            r++;
        if (l == r) maxLen = max(maxLen, l + r);
        if (r > l) l = 0, r = 0;
    }
    l = 0, r = 0;
    for (int i = s.size() - 1; i >= 0; i--) { // 从右向左统计
        if (s[i] == ')')
            r++;
        else
            l++;
        if (l == r) maxLen = max(maxLen, l + r);
        if (l > r) l = 0, r = 0;
    }
    return maxLen;
}
```

## 搜索旋转排序数组(中等)

假设按照升序排序的数组在预先未知的某个点上进行了旋转。( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。你可以假设数组中不存在重复的元素。你的算法时间复杂度必须是 O(log n) 级别。[搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

### 参考代码

```c++
int search(vector<int>& nums, int target) {
    if (!nums.size()) return -1;
    int l = 0, r = nums.size() - 1;
    while (l < r) {
        int mid = l + r >> 1;
        if (nums[mid] <= nums.back())
            r = mid;
        else
            l = mid + 1;
    }
    if (target <= nums.back()) {
        r = nums.size() - 1;
    } else {
        l = 0, r--;
    }
    while (l < r) {
        int mid = l + r >> 1;
        if (nums[mid] >= target)
            r = mid;
        else
            l = mid + 1;
    }
    return nums[l] == target ? l : -1;
}
```

## 在排序数组中查找元素的第一个和最后一个位置(中等)

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。你的算法时间复杂度必须是 O(log n) 级别。如果数组中不存在目标值，返回 [-1, -1]。[在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

### 参考代码

```c++
vector<int> searchRange(vector<int>& nums, int target) {
    if (!nums.size()) return {-1, -1};
    int l = 0, r = nums.size() - 1;
    while (l < r) { // 左边界
        int mid = l + r >> 1;
        if (nums[mid] >= target)
            r = mid;
        else
            l = mid + 1;
    }
    if (nums[l] != target) return {-1, -1};
    int t = l;
    l = 0, r = nums.size() - 1;
    while (l < r) { // 右边界
        int mid = l + r + 1 >> 1;
        if (nums[mid] <= target)
            l = mid;
        else
            r = mid - 1;
    }
    return {t, l};
}
```

## 组合总和(中等)

给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。candidates 中的数字可以无限制重复被选取。[组合总和](https://leetcode-cn.com/problems/combination-sum/)

### 参考代码

```c++
vector<vector<int>> res;
vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
    if (!candidates.size()) return res;
    vector<int> path;
    dfs(candidates, 0, target, path);
    return res;
}

void dfs(vector<int>& candidates, int idx, int target, vector<int>& path) {
    if (target == 0) {
        res.push_back(path);
        return;
    }
    for (int i = idx; i < candidates.size(); i++) {
        if (candidates[i] <= target) {
            path.push_back(candidates[i]);
            dfs(candidates, i, target - candidates[i], path);
            path.pop_back();
        }
    }
}
```

## 接雨水(困难)

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。[接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

### 参考代码

```c++
int trap(vector<int>& height) { // 单调栈
    int res = 0;
    stack<int> stk;
    for (int i = 0; i < height.size(); i++) {
        int last = 0;  // 记录之前的高度
        // 维护一个单调递减栈
        while (stk.size() && height[stk.top()] <= height[i]) {
            int t = stk.top();
            stk.pop();
            // 当前层的雨水
            res += (height[t] - last) * (i - t - 1);
            last = height[t];  // 之前的高度更新为当前高度
        }
        // 右边墙低于左边墙的情况
        if (stk.size()) res += (height[i] - last) * (i - stk.top() - 1);
        stk.push(i);
    }
    return res;
}

// 双指针
int trap(vector<int>& height) {
    if (height.size() < 2) return 0;
    int res = 0, l = 0, r = height.size() - 1, ml = 0, mr = 0;
    while (l < r) {
        if (height[l] < height[r]) { // 当右侧高于左侧，则储水量由左侧的最大值和当前值决定
            if (height[l] >= ml)  // 如果当前值大于左侧的最大值，则没有存储到水，更新左侧最大值
                ml = height[l];
            else // 否则，计算当前墙的储水量
                res += ml - height[l];
            l++;
        } else { // 若果左墙高于右墙，则储水量由右侧最大值和当前墙的高度决定
            if (height[r] >= mr) // 如果当前墙的高度大于右侧最大值，说明当前无储水，更新右侧最大值
                mr = height[r];
            else // 否则利用最大值和当前墙的高度计算当前储水量
                res += mr - height[r];
            r--;
        }
    }
    return res;
}
```

## 全排列(中等)

给定一个 没有重复 数字的序列，返回其所有可能的全排列。[全排列](https://leetcode-cn.com/problems/permutations/)

### 参考代码

```c++
vector<vector<int>> res;
vector<bool> st;
vector<vector<int>> permute(vector<int>& nums) {
    vector<int> path;
    st = vector<bool>(nums.size());
    dfs(nums, 0, path);
    return res;
}

void dfs(vector<int>& nums, int idx, vector<int>& path) {
    if (idx == nums.size()) {
        res.push_back(path);
        return;
    }
    for (int i = 0; i < nums.size(); i++) {
        if (!st[i]) {
            path.push_back(nums[i]);
            st[i] = true;
            dfs(nums, idx + 1, path);
            path.pop_back();
            st[i] = false;
        }
    }
}
```

## 旋转图像(中等)

给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。[旋转图像](https://leetcode-cn.com/problems/rotate-image/)

### 参考代码

```c++
void rotate(vector<vector<int>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    // 对角翻转
    for (int i = 0; i < m; i++) {
        for (int j = i; j < n; j++) {
            int t = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = t;
        }
    }
    // 水平翻转
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n / 2; j++) {
            int t = matrix[i][j];
            matrix[i][j] = matrix[i][n - j - 1];
            matrix[i][n - j - 1] = t;
        }
    }
}

void rotate(vector<vector<int>>& matrix) {
    if (matrix.size() == 0) {
        return;
    }
    // start 和 end 界定当前圈一行的起始和终止位置
    for (int start = 0, end = matrix.size() - 1; start < end;
            start++, end--) {
        // s,e 用于旋转四个坐标，旋转的次数小于当前圈的长度end
        for (int s = start, e = end; s < end; s++, e--) {
            int temp = matrix[start][s];
            matrix[start][s] = matrix[e][start];
            matrix[e][start] = matrix[end][e];
            matrix[end][e] = matrix[s][end];
            matrix[s][end] = temp;
        }
    }
}
```

## 字母异位词分组(中等)

给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。[字母异位词分组](https://leetcode-cn.com/problems/group-anagrams/)

### 参考代码

```c++
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> hash;
    for (auto s : strs) {
        string key = s;
        sort(key.begin(), key.end());
        hash[key].push_back(s);
    }
    vector<vector<string>> res;
    for (auto item : hash) res.push_back(item.second);
    return res;
}
```

## 最大子序列和(简单)

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。[最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

### 参考代码

```c++
int maxSubArray(vector<int>& nums) {
    int res = INT_MIN, last = 0;
    for (auto n : nums) {
        int t = max(last, 0) + n;
        res = max(res, t);
        last = t;
    }
    return res;
}
```

## 跳跃游戏(中等)

给定一个非负整数数组，你最初位于数组的第一个位置。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断你是否能够到达最后一个位置。[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

### 参考代码

```c++
bool canJump(vector<int>& nums) {
    int maxPos = 0;
    for (int i = 0; i < nums.size(); i++) {
        if (i > maxPos) return false;
        maxPos = max(maxPos, nums[i] + i);
    }
    return true;
}
```

## 合并区间(中等)

给出一个区间的集合，请合并所有重叠的区间。[合并区间](https://leetcode-cn.com/problems/merge-intervals/)

### 参考代码

```c++
static bool cmp(vector<int> a, vector<int> b) { return a[0] < b[0]; }

vector<vector<int>> merge(vector<vector<int>>& intervals) {
    vector<vector<int>> res;
    if (!intervals.size()) return res;
    sort(intervals.begin(), intervals.end(), cmp); // 先排序
    res.push_back(intervals[0]);
    int idx = 0;
    for (int i = 1; i < intervals.size(); i++) {
        if (res[idx][1] >= intervals[i][0])
            res[idx][1] = max(res[idx][1], intervals[i][1]);
        else {
            res.push_back(intervals[i]);
            idx++;
        }
    }
    return res;
}
```

## 不同路径(中等)

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？[不同路径](https://leetcode-cn.com/problems/unique-paths/)

### 参考代码

```c++
int uniquePaths(int m, int n) {
    // 动态规划：状态表示：dp[i][j]表示到达i，j这个位置的所有路径
    vector<vector<int>> dp(m, vector<int>(n));
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (!i || !j)
                dp[i][j] = 1; // base case
            else
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // 状态计算
        }
    }
    return dp[m - 1][n - 1];
}
```

## 最小路径和(中等)

给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。[最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

### 参考代码

```c++
int minPathSum(vector<vector<int>>& grid) {
    int m = grid.size(), n = grid[0].size();
    vector<vector<int>> dp(m, vector<int>(n)); // 表示到达位置i，j的最小路径和
    dp[0][0] = grid[0][0]; // base case
    for (int i = 1; i < m; i++) dp[i][0] = dp[i - 1][0] + grid[i][0];
    for (int j = 1; j < n; j++) dp[0][j] = dp[0][j - 1] + grid[0][j];
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]; // 状态转移
        }
    }
    return dp[m - 1][n - 1];
}
```

## 爬楼梯(简单)

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？[ 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

### 参考代码

```c++
int climbStairs(int n) {
    if (n == 1) return 1;
    if (n == 2) return 2;
    int a = 1, b = 2, res;
    for (int i = 3; i <= n; i++) {
        res = a + b;
        a = b;
        b = res;
    }
    return res;
}
```

## 编辑距离(困难)

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。你可以对一个单词进行如下三种操作：插入一个字符，删除一个字符，替换一个字符。[编辑距离](https://leetcode-cn.com/problems/edit-distance/)

### 参考代码

```c++
int minDistance(string w1, string w2) {
    int m = w1.size(), n = w2.size();
    vector<vector<int>> dp(m + 1, vector<int>(n + 1));
    for (int i = 0; i <= m; i++) dp[i][0] = i;
    for (int j = 0; j <= n; j++) dp[0][j] = j;
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + 1; // 插入、删除
            dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + (w1[i - 1] != w2[j - 1])); // 替换
        }
    }
    return dp[m][n];
}
```

## 颜色分类(中等)

给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。[颜色分类](https://leetcode-cn.com/problems/sort-colors/)

### 参考代码

```c++
void sortColors(vector<int>& nums) {
    int l = 0, r = nums.size() - 1, cur = 0;
    while (cur <= r) {
        if (nums[cur] == 0) {
            swap(nums[cur], nums[l]);
            l++, cur++;
        } else if (nums[cur] == 2) {
            swap(nums[cur], nums[r]);
            r--;
        } else
            cur++;
    }
}
```

## 最小覆盖子串(困难)

给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。[最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

### 参考代码

```c++
string minWindow(string s, string t) {
    unordered_map<char, int> need, window; // 分别记录需要的字符及次数，窗口的字符及次数
    for (auto c : t) need[c]++; // 统计需要的字符
    int l = 0, r = 0, idx = 0; // 左指针，右指针，记录最左侧的索引
    int matched = 0, minLen = INT_MAX; // 匹配的字符数目，最小长度
    while (r < s.size()) {
        auto c = s[r];
        if (need.count(c)) { // 如果需要的字符串中包含c
            window[c]++;
            if (window[c] == need[c]) matched++; // 如果数量相同，说明匹配了一个字符
        }
        r++;
        while(matched== need.size()) { // 如果已经匹配，则缩小窗口
            if (r - l < minLen) { // 更新长度
                minLen = r - l;
                idx = l;
            }
            auto c = s[l];
            if(need.count(c)) { // 缩小窗口
                window[c]--;
                if (window[c] < need[c]) matched--;
            }
            l++;

        }
    }
    return minLen == INT_MAX ? "" : s.substr(idx, minLen);
}
```

## 子集(中等)

给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。[子集](https://leetcode-cn.com/problems/subsets/)

### 参考代码

```c++
vector<vector<int>> res;
vector<vector<int>> subsets(vector<int>& nums) {
    vector<int> path;
    dfs(nums, 0, path);
    return res;
}

void dfs(vector<int>& nums, int idx, vector<int>& path) {
    res.push_back(path);
    for (int i = idx; i < nums.size(); i++) {
        path.push_back(nums[i]);
        dfs(nums, i + 1, path);
        path.pop_back();
    }
}
```

## 单词搜索(中等)

给定一个二维网格和一个单词，找出该单词是否存在于网格中。单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。[单词搜索](https://leetcode-cn.com/problems/word-search/)

### 参考代码

```c++
int m, n;
int dx[4] = {0, -1, 0, 1}, dy[4] = {-1, 0, 1, 0};
bool exist(vector<vector<char>>& board, string word) {
    if (!board.size() || !board[0].size()) return false;
    m = board.size(), n = board[0].size();
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (board[i][j] == word[0] && dfs(board, i, j, 0, word))
                return true;
        }
    }
    return false;
}

bool dfs(vector<vector<char>>& board, int x, int y, int idx, string& word) {
    if (board[x][y] != word[idx]) return false;
    if (idx == word.size() - 1) return true;
    board[x][y] = '.';
    for (int i = 0; i < 4; i++) {
        int a = x + dx[i], b = y + dy[i];
        if (a >= 0 && a < m && b >= 0 && b < n)
            if (dfs(board, a, b, idx + 1, word)) return true;
    }
    board[x][y] = word[idx];
    return false;
}
```

## 柱状图中最大的矩形(困难)

给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积。[柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

### 参考代码

```c++
int largestRectangleArea(vector<int>& heights) {
    int n = heights.size();
    vector<int> left(n), right(n);
    stack<int> stk;
    for (int i = 0; i < n; i++) { // 找左边最近的小于当前柱子的位置
        while (stk.size() && heights[stk.top()] >= heights[i]) stk.pop();
        if (stk.empty())
            left[i] = -1;
        else
            left[i] = stk.top();
        stk.push(i);
    }
    while (stk.size()) stk.pop();
    for (int i = n - 1; i >= 0; i--) { // 找右边最近的小于当前柱子的位置
        while (stk.size() && heights[stk.top()] >= heights[i]) stk.pop();
        if (stk.empty())
            right[i] = n;
        else
            right[i] = stk.top();
        stk.push(i);
    }
    int res = 0;
    for (int i = 0; i < n; i++) { // 寻找最大值
        res = max(res, heights[i] * (right[i] - left[i] - 1));
    }
    return res;
}
```

## 最大矩形(困难)

给定一个仅包含 0 和 1 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。[最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

思路：使用数据栈，借助柱状图中面积最大的矩形，首先沿着某一维度累加1的个数(遇到0时重置)，可得到沿着另一维度的柱状图，每个位置的数字表示到当前位置有多少个1，然后沿着另一个维度 按照柱状图中最大矩形求的最大矩形。时间复杂度：O(MN)，空间复杂度：O(M)或O(N)。

### 参考代码

```c++
int maximalRectangle(vector<vector<char>>& matrix) {
    int m = matrix.size(), n = matrix[0].size();
    vector<int> dp(n);
    int res = 0;
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            dp[j] = matrix[i][j] == '1' ? dp[j] + 1 : 0;
        }
        res = max(res, largestRectangleArea(dp));
    }
    return res;
}

int largestRectangleArea(vector<int>& heights) {
    int n = heights.size();
    vector<int> left(n), right(n);
    stack<int> stk;
    for (int i = 0; i < n; i++) {
        while (stk.size() && heights[stk.top()] >= heights[i]) stk.pop();
        if (stk.empty())
            left[i] = -1;
        else
            left[i] = stk.top();
        stk.push(i);
    }
    while (stk.size()) stk.pop();
    for (int i = n - 1; i >= 0; i--) {
        while (stk.size() && heights[stk.top()] >= heights[i]) stk.pop();
        if (stk.empty())
            right[i] = n;
        else
            right[i] = stk.top();
        stk.push(i);
    }
    int res = 0;
    for (int i = 0; i < n; i++) {
        res = max(res, heights[i] * (right[i] - left[i] - 1));
    }
    return res;
}
```

## 二叉树的中序遍历(中等)

给定一个二叉树，返回它的中序 遍历。[二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

### 参考代码

```c++
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
};

class Solution {
   public:
    vector<int> res;
    // 递归版本
    vector<int> inorderTraversal(TreeNode* root) {
        dfs(root);
        return res;
    }

    void dfs(TreeNode* root) {
        if (!root) return;
        dfs(root->left);
        res.push_back(root->val);
        dfs(root->right);
    }

    // 非递归版
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        while (root || stk.size()) {
            while (root) {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
    }
};
```

## 不同的二叉搜索树(中等)

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？[不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

### 参考代码

```c++
class Solution {
   public:
    /**
     * 思路：假设n个节点存在二叉搜索树的个数是G(n)，令f(i)表示以i为根节点的二叉搜索树，则：
     * G(n) = f(1) + f(2) + ... + f(n)
     * 当以i为根节点时：f(i) = G(i-1) * G(n-i),左子树有i-1个结点，右子树有n-i个结点
     * 综上有：G(n) = G(0)*G*(n-1) + G(1)*G(n-2) + ... + G(n-1)*G(0) 卡特兰数 
     * 通过dp来实现
     */
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```

## 验证二叉搜索树(中等)

给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：节点的左子树只包含小于当前节点的数。节点的右子树只包含大于当前节点的数。所有左子树和右子树自身必须也是二叉搜索树。[验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

### 参考代码

```c++
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

class Solution {
   public:
    typedef long long LL;
    // 判断当前结点是否在正确的区间
    bool isValidBST(TreeNode* root) { return dfs(root, INT_MIN, INT_MAX); }

    bool dfs(TreeNode* root, LL minV, LL maxV) {
        if (!root) return true;
        if (root->val < minV || root->val > maxV) return false; // 不在正确的区间，返回false
        // 缩小区间 dfs左右子树
        return dfs(root->left, minV, root->val - 1ll) &&
               dfs(root->right, root->val + 1ll, maxV);
    }
};
```

## 对称二叉树(简单)

给定一个二叉树，检查它是否是镜像对称的。

### 参考代码

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
       return dfs(root, root);
    }

    bool dfs(TreeNode* r1, TreeNode* r2) {
        if (!r1 && !r2) return true;
        if (!r1 || !r2) return false;
        if (r1->val != r2->val) return false;
        return dfs(r1->left, r2->right) && dfs(r1->right, r2->left);
    }
};
```

## 二叉树的层序遍历(中等)

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

### 参考代码

```c++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        if (!root) return res;
        queue<TreeNode*> q;
        q.push(root);
        while(q.size()) {
            int len = q.size();
            vector<int> t;
            for (int i = 0; i < len; i++) {
                auto node = q.front();
                q.pop();
                t.push_back(node->val);
                if (node->left) q.push(node->left);
                if (node->right) q.push(node->right);
            }
            res.push_back(t);
        }
        return res;
    }
};
```

## 二叉树的最大深度(简单)

给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

### 参考代码

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (!root) return 0;
        int l = maxDepth(root->left);
        int r = maxDepth(root->right);
        return max(l, r) + 1;
    }
};
```

## 从前序和中序遍历序列构造二叉树(中等)

根据一棵树的前序遍历与中序遍历构造二叉树。

### 参考代码

```c++
class Solution {
public:
    unordered_map<int, int> pos;
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        int n = preorder.size();
        for (int i = 0; i < n; i++) pos[inorder[i]] = i;
        return dfs(preorder, inorder, 0, n - 1, 0, n - 1);
    }

    TreeNode* dfs(vector<int>& preorder, vector<int>& inorder, int pl, int pr, int il, int ir) {
        if (pl > pr) return nullptr;
        int val = preorder[pl];
        int k = pos[val];
        int len = k - il;
        auto root = new TreeNode(val);
        root->left = dfs(preorder, inorder, pl + 1, pl + len, il, k - 1);
        root->right = dfs(preorder, inorder, pl + len + 1, pr, k + 1, ir);
        return root;
    }
};
```

## 二叉树展开为链表(中等)

给定一个二叉树，原地将它展开为一个单链表。[二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

### 参考代码

```c++
class Solution {
public:
    TreeNode* pre = nullptr;
    void flatten(TreeNode* root) {
        if (!root) return;
        flatten(root->right);
        flatten(root->left);
        root->right = pre;
        root->left = nullptr;
        pre = root;
    }
};
```

## 买卖股票的最佳时机(简单)

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。注意：你不能在买入股票前卖出股票。

### 参考代码

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int dp_i_0 = 0, dp_i_1 = INT_MIN;
        for (auto p : prices) {
            dp_i_0 = max(dp_i_0, dp_i_1 + p);
            dp_i_1 = max(dp_i_1, -p);
        }
        return dp_i_0;
    }
};
```

## 二叉树中的最大路径和(困难)

给定一个非空二叉树，返回其最大路径和。本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。[二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

### 参考代码

```c++
class Solution {
public:
    int res = INT_MIN;
    int maxPathSum(TreeNode* root) {
        dfs(root);
        return res;
    }
    // 枚举所有的顶点
    int dfs(TreeNode* root) {
        if (!root) return 0;
        int l = dfs(root->left); // 计算左子树最大和
        int r = dfs(root->right); // 计算右子树最大和
        res = max(res, l + r + root->val); //更新答案
        return max(0, max(l, r) + root->val);
    }
};
```

## 最长连续序列(困难)

给定一个未排序的整数数组，找出最长连续序列的长度。要求算法的时间复杂度为 O(n)。[最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

### 参考代码

```c++
class Solution {
   public:
    /**
     * 使用哈希表
     * 时间复杂度：O(n)
     */
    int longestConsecutive(vector<int>& nums) {
        unordered_set<int> hash;
        for (auto n : nums) hash.insert(n);
        int res = 0;
        for (auto n : hash) { // 注意这儿需要从set中枚举
            if (!hash.count(n - 1)) {  // 从没有比当前数小一的数开始
                int len = 0;
                // 统计以当前数字开始的连续序列长度
                while (hash.count(n)) {
                    len++, n++;
                }
                res = max(res, len);
            }
        }
        return res;
    }

    // 并查集
    unordered_map<int, int> p;
    int longestConsecutive(vector<int>& nums) {
        for (auto n : nums) p[n] = n + 1;
        int res = 0;
        for (auto n : nums) {
            int r = find(n + 1);
            res = max(res, r - n);
        }
        return res;
    }

    int find(int x) {
        return p.count(x) ? p[x] = find(p[x]) : x;
    }
}
```

## 只出现一次的数字(简单)

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

### 参考代码

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for (auto n : nums) res ^= n;
        return res;
    }
};
```

## 单词拆分(中等)

给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。[单词拆分](https://leetcode-cn.com/problems/word-break/)

### 参考代码

```c++
class Solution {
   public:
    /**
     * 动态规划
     * 状态表示：dp[i]表示字符串前i个字符能否由单词表中的单词表示
     * 状态计算：dp[i] = true 如果前i个字符中从后面拆出来一个单词表中的单词，
     * 并且剩余的字符串dp[i-len(单词)]可以用单词表中单词表示时。
     * 时间复杂度：O(n^2)
     */
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> dict;
        for (auto d : wordDict) dict.insert(d);
        vector<bool> dp(s.size() + 1);
        dp[0] = true;
        for (int i = 1; i <= s.size(); i++) {
            for (int j = 0; j < i; j++) {
                if (dp[j] && dict.count(s.substr(j, i - j))) { // 满足条件说明，可以表示，设置为true后直接跳出循环。
                    dp[i] = true;
                    break;
                }
            }
        }
        return dp[s.size()];
    }
};
```

## 环形链表(简单)

给定一个链表，判断链表中是否有环。

### 参考代码

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        auto s = head;
        auto f = head;
        while(f && f->next) {
            f = f->next->next;
            s = s->next;
            if (s == f) return true;
        }
        return false;
    }
};
```

## 环形链表II(中等)

给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。

### 参考代码

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        auto s = head;
        auto f = head;
        while (f && f->next) {
            f = f->next->next;
            s = s->next;
            if (s == f) break;
        }
        if (!f || !f->next) return nullptr;
        s = head;
        while (s != f) {
            s = s->next;
            f = f->next;
        }
        return s;
    }
};
```

## LRU 缓存机制(中等)

运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。

### 参考代码

```c++
class LRUCache {
public:
    typedef pair<int, int> PII;
    unordered_map<int, list<PII>::iterator> m; // 哈希表
    list<PII> cache; // 双向链表
    int cap = 0;

    LRUCache(int capacity) {
        cap = capacity;
    }

    int get(int key) {
        if (m.count(key)) {
            auto t = *m[key]; // 找到双向链表中的结点
            cache.erase(m[key]); // 先删除该节点
            cache.push_front(t);  // 再把节点放在链表头
            m[key] = cache.begin(); // 把哈希表中的值更新为链接头
            return t.second;
        } else return -1;
    }

    void put(int key, int value) {
        if (m.count(key)) { // 如果包含键，则直接删除链表结点
            cache.erase(m[key]);
        } else {
            if (cache.size() == cap) {
                auto last = cache.back(); // 记录最后一个结点的值
                cache.pop_back(); // 删除最后一个结点
                m.erase(last.first); // 删除最后一个结点在哈希表中的键
            }
        }
        cache.push_front({key, value});
        m[key] = cache.begin();
    }
};
```

## 归并排序链表(中等)

在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。[归并排序链表](https://leetcode-cn.com/problems/sort-list/)

### 参考代码

```c++
struct ListNode {
    int val;
    ListNode* next;
    ListNode(int x) : val(x), next(nullptr) {}
};

class Solution {
   public:
    /**
     * 递归版本
     * 时间复杂度：O(nlogn)
     * 空间复杂度：O(logn)
     */
    ListNode* sortList(ListNode* head) {
        if (!head || !head->next) return head;  // 边界条件
        auto s = head;
        auto f = head;
        // 快慢指针找中间结点
        while (!f || !f->next) {
            f = f->next->next;
            s = s->next;
        }
        auto t = s->next;  // 断开链表
        s->next = nullptr;
        auto l = sortList(head);        // 递归排序前部分
        auto r = sortList(t);           // 递归排序后部分
        auto dummy = new ListNode(-1);  // 构建虚拟结点
        auto cur = dummy;
        // 归并两部分
        while (l && r) {
            if (l->val < r->val) {
                cur->next = l;
                l = l->next;
                cur = cur->next;
            } else {
                cur->next = r;
                r = r->next;
                cur = cur->next;
            }
        }
        while (l) {
            cur->next = l;
            l = l->next;
            cur = cur->next;
        }
        while (r) {
            cur->next = r;
            r = r->next;
            cur = cur->next;
        }
        return dummy->next;
    }

    /**
     * 迭代版
     * 时间复杂度：O(nlogn)
     * 空间复杂度：O(1)
     */
    ListNode* sortList(ListNode* head) {
        int n = 0;
        for (auto p = head; p; p = p->next) n++; // 统计节点数量
        auto dummy = new ListNode(-1); // 构建虚拟结点
        dummy->next = head;
        // 枚举区间长度
        for (int i = 1; i < n; i *= 2) {
            auto cur = dummy;
            // 枚举每隔两个区间的起点
            for (int j = 0; j + i < n; j += i * 2) {
                auto first = cur->next, second = first;
                // 寻找第二个区间的起点
                for (int k = 0; k < i; k++) second = second->next;
                int f = 0, s = 0;
                // 归并
                while (f < i && s < i && second) {
                    if (first->val < second->val) {
                        cur->next = first;
                        cur = cur->next;
                        first = first->next;
                        f++;
                    } else{
                        cur->next = second;
                        cur = cur->next;
                        second = second->next;
                        s++;
                    }
                }
                while (f < i) {
                    cur->next = first;
                    cur = cur->next;
                    first = first->next;
                    f++;
                }
                while (s < i && second) {
                    cur->next = second;
                    cur = cur->next;
                    second = second->next;
                    s++;
                }
                // 转到下下一个区间
                cur->next = second;
            }
        }
        return dummy->next;
    }
};
```

## 乘积最大子数组(中等)

给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。[乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

### 参考代码

```c++
class Solution {
   public:
    /**
     * 动态规划
     * 状态表示：dpmax[i]表示到i位置最大的乘积，dpmin[i]表示到i位置最小的乘积
     * 状态计算: 见代码
     * 时间复杂度：O(n)
     * 空间复杂度：O(n)
     */
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        vector<int> dpmax(nums), dpmin(nums); // dpmax和dpmin分别记录最大值和最小值
        for (int i = 1; i < n; i++) {
            if (nums[i] > 0) { // 如果当前数是正数，则正常计算
                dpmax[i] = max(dpmax[i - 1] * nums[i], nums[i]);
                dpmin[i] = min(dpmin[i - 1] * nums[i], nums[i]);
            } else { // 如果当前数是负数，则最大数变最小数，最小数变最大数 
                dpmax[i] = max(dpmin[i - 1] * nums[i], nums[i]);
                dpmin[i] = min(dpmax[i - 1] * nums[i], nums[i]);
            }
        }
        int res = INT_MIN;
        for (int i = 0; i < n; i++) {
            res = max(res, max(dpmax[i], dpmin[i]));
        }
        return res;
    }

    /**
     * 空间优化
     * 时间复杂度：O(n)
     * 空间复杂度：O(1)
     */
    int maxProduct(vector<int>& nums) {
        int n = nums.size();
        int minV = 1, maxV = 1, res = INT_MIN;
        for (auto n : nums) {
            if (n < 0) {
                int t = maxV;
                maxV = minV;
                minV = t;
            }
            maxV = max(maxV * n, n);
            minV = min(minV * n, n);
            res = max(res, maxV);
        }
        return res;
    }
};
```

## 相交链表(简单)

编写一个程序，找到两个单链表相交的起始节点。

### 参考代码

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        auto p = headA, q = headB;
        while (p != q) {
            if (p) p = p->next;
            else p = headB;
            if (q) q = q->next;
            else q = headA;
        }
        return p;
    }
};
```

## 多数元素(简单)

给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

### 参考代码

```c++
class Solution {
public:
    /**
     * 摩尔投票法
     * 时间复杂度：O(n)
     * 空间复杂度：O(1)
     */
    int majorityElement(vector<int>& nums) {
        int res, cnt = 0;
        // 摩尔投票
        for (auto n : nums) {
            if (!cnt) {
                res = n;
                cnt = 1;
            } else if (n == res) cnt++;
            else cnt--;
        }
        cnt = 0;
        // 验证
        for (auto n : nums) if (n == res) cnt++;
        return cnt > nums.size() / 2 ? res : -1;
    }
};
```

## 打家劫舍(简单)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

### 参考代码

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (!n) return 0;
        int dp_i_1 = 0, dp_i_2 = 0, dp_i = 0;
        for (auto n : nums) {
            dp_i = max(dp_i_1, dp_i_2 + n);
            dp_i_2 = dp_i_1;
            dp_i_1 = dp_i;
        }
        return dp_i;
    }
};
```

## 岛屿数量(中等)

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。[岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

### 参考代码

```c++
class Solution {
   public:
    int m, n;
    int dx[4] = {0, -1, 0, 1}, dy[4] = {-1, 0, 1, 0};
    // 二维深搜
    int numIslands(vector<vector<char>>& grid) {
        if (!grid.size() || !grid[0].size()) return 0;
        m = grid.size(), n = grid[0].size();
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1') {
                    dfs(grid, i, j);
                    res++;
                }
            }
        }
        return res;
    }

    void dfs(vector<vector<char>>& grid, int x, int y) {
        grid[x][y] = '0';
        for (int i = 0; i < 4; i++) {
            int a = x + dx[i], b = y + dy[i];
            if (a >= 0 && a < m && b >= 0 && b < n && grid[a][b] == '1')
                dfs(grid, a, b);
        }
    }
};
```

## 反转链表(简单)

反转一个单链表。

### 参考代码

```c++
class Solution {
public:
    /**
     * 递归版本
     */
    ListNode* reverseList(ListNode* head) {
        if (!head || !head->next) return head;
        auto last = reverseList(head->next);
        head->next->next = head;
        head->next = nullptr;
        return last;
    }
    /**
     * 非递归版本
     */
    ListNode* reverseList(ListNode* head) {
        ListNode* pre = nullptr;
        auto cur = head;
        while (cur) {
            auto nx = cur->next;
            cur->next = pre;
            pre = cur;
            cur = nx;
        }
        return pre;
    }
};
```

## 课程表(中等)

